{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Bis e processadores"},{"location":"Sobre-Criterios-de-Avaliacao/","text":"Crit\u00e9rios de Avalia\u00e7\u00e3o \u00b6 Os crit\u00e9rios de avalia\u00e7\u00e3o a seguir ser\u00e3o aplicados a disciplina: Crit\u00e9rios \u00b6 Os alunos devem: Ter acumulado no m\u00ednimo 50 pontos de HW (\u00c1lgebra booleana, l\u00f3gica combinacional, unidade l\u00f3gica aritm\u00e9tica, l\u00f3gica sequencial, CPU) nas provas Ter acumulado no m\u00ednimo 50 pontos de SW (Dadoss digitais, assembly, assembler, m\u00e1quina virtual, VM translator) nas provas Ter no m\u00ednimo conceito C na m\u00e9dia de todos os Projetos nos quesitos Individual e Grupo Ter no m\u00e1ximo duas notas inferiores a C na avalia\u00e7\u00e3o individual e uma nota inferior a C na avalia\u00e7\u00e3o coletiva dos Projetos Provas \u00b6 Ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (A1, A2, A3, A4) que ser\u00e3o aplicadas ao longo do semestre. A nota final de prova (atingido atingido o crit\u00e9rio) ser\u00e1 a m\u00e9dia da soma das notas de HW e SW aplicado o conceito (final da p\u00e1gina). Provas Pontua\u00e7\u00e3o HW Pontua\u00e7\u00e3o SW Pontua\u00e7\u00e3o Total Conte\u00fado A1 30 10 40 \u00c1lgebra booleana, dados digitais A2 40 10 50 Dados digitais, l\u00f3gica combinacional, ULA, l\u00f3gica sequencial A3 20 35 55 Assembly, CPU A4 10 45 55 Assembler, m\u00e1quina virtual, VM translator, \u00e1lgebra booleana Total 100 100 200 Projetos (APS) \u00b6 O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. A nota final de projeto (quando atingindo o crit\u00e9rio) ser\u00e1 a m\u00e9dia de todas as entregas, aplicado a regra a baixo. Contribui\u00e7\u00e3o individual menor que C Nota final nenhuma M\u00e9dia uma M\u00e9dia - 1 conceito duas M\u00e9dia - 2 conceitos tr\u00eas ou mais Fora do crit\u00e9rio Nota final \u00b6 A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([Prova, Projeto]) Conceito \u00b6 A seguinte tabela ser\u00e1 aplicada para o c\u00e1lculo dos conceitos. Nota Conceito 10 A+ 9 A 8 B+ 7 B 6 C+ 5 C 4-3 D 3-0 I","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios-de-avaliacao","text":"Os crit\u00e9rios de avalia\u00e7\u00e3o a seguir ser\u00e3o aplicados a disciplina:","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios","text":"Os alunos devem: Ter acumulado no m\u00ednimo 50 pontos de HW (\u00c1lgebra booleana, l\u00f3gica combinacional, unidade l\u00f3gica aritm\u00e9tica, l\u00f3gica sequencial, CPU) nas provas Ter acumulado no m\u00ednimo 50 pontos de SW (Dadoss digitais, assembly, assembler, m\u00e1quina virtual, VM translator) nas provas Ter no m\u00ednimo conceito C na m\u00e9dia de todos os Projetos nos quesitos Individual e Grupo Ter no m\u00e1ximo duas notas inferiores a C na avalia\u00e7\u00e3o individual e uma nota inferior a C na avalia\u00e7\u00e3o coletiva dos Projetos","title":"Crit\u00e9rios"},{"location":"Sobre-Criterios-de-Avaliacao/#provas","text":"Ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (A1, A2, A3, A4) que ser\u00e3o aplicadas ao longo do semestre. A nota final de prova (atingido atingido o crit\u00e9rio) ser\u00e1 a m\u00e9dia da soma das notas de HW e SW aplicado o conceito (final da p\u00e1gina). Provas Pontua\u00e7\u00e3o HW Pontua\u00e7\u00e3o SW Pontua\u00e7\u00e3o Total Conte\u00fado A1 30 10 40 \u00c1lgebra booleana, dados digitais A2 40 10 50 Dados digitais, l\u00f3gica combinacional, ULA, l\u00f3gica sequencial A3 20 35 55 Assembly, CPU A4 10 45 55 Assembler, m\u00e1quina virtual, VM translator, \u00e1lgebra booleana Total 100 100 200","title":"Provas"},{"location":"Sobre-Criterios-de-Avaliacao/#projetos-aps","text":"O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. A nota final de projeto (quando atingindo o crit\u00e9rio) ser\u00e1 a m\u00e9dia de todas as entregas, aplicado a regra a baixo. Contribui\u00e7\u00e3o individual menor que C Nota final nenhuma M\u00e9dia uma M\u00e9dia - 1 conceito duas M\u00e9dia - 2 conceitos tr\u00eas ou mais Fora do crit\u00e9rio","title":"Projetos (APS)"},{"location":"Sobre-Criterios-de-Avaliacao/#nota-final","text":"A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([Prova, Projeto])","title":"Nota final"},{"location":"Sobre-Criterios-de-Avaliacao/#conceito","text":"A seguinte tabela ser\u00e1 aplicada para o c\u00e1lculo dos conceitos. Nota Conceito 10 A+ 9 A 8 B+ 7 B 6 C+ 5 C 4-3 D 3-0 I","title":"Conceito"},{"location":"Sobre-Objetivos-de-Aprendizagem/","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Conte\u00fado Program\u00e1tico: L\u00f3gica Combinacional Unidade L\u00f3gica Aritm\u00e9tica L\u00f3gica Sequencial L\u00f3gica de Controle Linguagem de M\u00e1quinas Assembly Assembler M\u00e1quina Virtual Controle de programa Linguagem Orientada a Objetos An\u00e1lise L\u00e9xica e Sint\u00e1tica Linguagens","title":"Sobre Objetivos de Aprendizagem"},{"location":"Sobre-Rubricas/","text":"Rubricas individuais \u00b6 Voc\u00ea ser\u00e1 avaliado conforme o seu papel no desenvolvimento do projeto. Podendo ser: Facilitador Desenvolvedor O Facilitador ser\u00e1 atribu\u00eddo pelo professor antes do inicio do projeto. Facilitador \u00b6 O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, d\u00e1 feedback de issues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.5: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 I Desenvolvedor \u00b6 Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto Tip Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Rubricas individuais"},{"location":"Sobre-Rubricas/#rubricas-individuais","text":"Voc\u00ea ser\u00e1 avaliado conforme o seu papel no desenvolvimento do projeto. Podendo ser: Facilitador Desenvolvedor O Facilitador ser\u00e1 atribu\u00eddo pelo professor antes do inicio do projeto.","title":"Rubricas individuais"},{"location":"Sobre-Rubricas/#facilitador","text":"O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, d\u00e1 feedback de issues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.5: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 I","title":"Facilitador"},{"location":"Sobre-Rubricas/#desenvolvedor","text":"Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto Tip Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Desenvolvedor"},{"location":"Sobre/","text":"Sobre \u00b6 Bits e Processadores: Curso: Ci\u00eancia da Computac\u00e3o Disciplina: Bits e Processadores - Insper - 2022a. Prof. Rafael Corsi - rafael.corsi@insper.edu.br Local: Dev. Space \u00a9 Todos os direitos reservados Criado por prof. Rafael Corsi / rafael.corsi@insper.edu.br , baseada em Elementos de Sistemas . Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Motiva\u00e7\u00e3o \u00b6 Desenvolver um computador do ZERO! Avalia\u00e7\u00e3o \u00b6 A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (A1,A2,A3,A4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. Bibliografia \u00b6 Bibliografia do curso. B\u00e1sica \u00b6 NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, Second Edition: Building a Modern Computer from First Principles MIT Press, 2021 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 HENNESSY, JOHN L., AND DAVID A. PATTERSON. Computer architecture: a quantitative approach, Sixth Edition. Elsevier, 2017. Complementar \u00b6 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Sobre"},{"location":"Sobre/#sobre","text":"Bits e Processadores: Curso: Ci\u00eancia da Computac\u00e3o Disciplina: Bits e Processadores - Insper - 2022a. Prof. Rafael Corsi - rafael.corsi@insper.edu.br Local: Dev. Space \u00a9 Todos os direitos reservados Criado por prof. Rafael Corsi / rafael.corsi@insper.edu.br , baseada em Elementos de Sistemas .","title":"Sobre"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores.","title":"Objetivos de aprendizagem"},{"location":"Sobre/#motivacao","text":"Desenvolver um computador do ZERO!","title":"Motiva\u00e7\u00e3o"},{"location":"Sobre/#avaliacao","text":"A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (A1,A2,A3,A4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso.","title":"Avalia\u00e7\u00e3o"},{"location":"Sobre/#bibliografia","text":"Bibliografia do curso.","title":"Bibliografia"},{"location":"Sobre/#basica","text":"NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, Second Edition: Building a Modern Computer from First Principles MIT Press, 2021 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 HENNESSY, JOHN L., AND DAVID A. PATTERSON. Computer architecture: a quantitative approach, Sixth Edition. Elsevier, 2017.","title":"B\u00e1sica"},{"location":"Sobre/#complementar","text":"PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Complementar"},{"location":"class/comb-lab-1/","text":"Lab 5: MyHDL \u00b6 Leitura pr\u00e9via necess\u00e1ria: MyHDL/MyHDL B\u00e1sico Teoria/FPGA (TODO) Este laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( L\u00f3gica-Combinacional ), onde iremos criar componentes de hardware que ser\u00e3o os alicerces do nosso computador. Primeiro precisamos praticar um pouco de MyHDL e entender a ferramenta e o fluxo de compila\u00e7\u00e3o, teste e como conseguimos executar o hardware em uma FPGA. Os exerc\u00edcios dos laborat\u00f3rios est\u00e3o localizados no reposit\u00f3rio: https://github.com/rafaelcorsi/bits-e-proc-labs , cada aluno de forma individual deve realizar um fork do reposit\u00f3rio e trabalhar individualmente nele. Os laborat\u00f3rios n\u00e3o po ffssuem entregas, mas devem ser realizados para estudo. Exercise Realize um fork do reposit\u00f3rio de labs Clone o reposit\u00f3rio para a sua m\u00e1quina Exercise N\u00f3s iremos trabalhar sempre com um ambiente virtual do python 3.8, para isso ser\u00e1 necess\u00e1rio realizar as seguintes opera\u00e7\u00f5es dentro da pasta clonada : python3.8 -m venv env . env/bin/activate pip3 install -r requirements.txt Warning Sempre que for abrir um terminal novo e acessar a pasta, ser\u00e1 necess\u00e1rio ativar o ambiente virtual: . env/bin/activate Se for utilizar o VSCODE para fazer o desenvolvimento dos projetos e exerc\u00edcios, basta abrir a pasta raiz do reposit\u00f3rio que o code j\u00e1 utiliza o ambiente virtual (eu criei o arquivo .vscode/settings.json que configura isso.) pytest \u00b6 Bits e Processadores utiliza uma metodologia de desenvolvimento de projeto chamada de test driven development (TDD) , ou seja, para cada etapa do projeto teremos um teste associado a ele. Os testes podem ser do tipo unit\u00e1rio e de integra\u0107\u00e3o. Para realizarmos os testes em python utilizaremos o m\u00f3dulo pytest e o plugin de dev-life (para fazer o report do progresso de voc\u00eas para o servidor). Cada exerc\u00edcio possui um arquivo com o prefixo test_ que excita o componente que voc\u00eas ir\u00e3o desenvolver e valida a sa\u00edda esperada. A seguir um exemplo do teste falhando e ent\u00e3o solucionado e testado novamente: Exercise Navegue no terminal at\u00e9 a pasta comb Execute no terminal pytest -k exe1 O teste deve falhar pois n\u00e3o foi implementado ainda. Edite o arquivo comb_modules.py com a l\u00f3gica a seguir: def exe1(): - pass + q.next = a or (and b) Execute o pytest novamente e note que o c\u00f3digo passa no teste. Info Todo o teste executado no reposit\u00f3rio ser\u00e1 submetido ao servidor de dev-life para processamento futuro e acompanhamento individual da participac\u00e3o de voc\u00eas nos projetos. Portanto, facam individualmente os laborat\u00f3rios. Progress Come\u00e7ando o laborat\u00f3rio. Praticando - Parte 1 \u00b6 Vamos comecar descrevendo algumas circuitos l\u00f3gicos combinacionais bem simples em MyHDL. Exercise Para cada exerc\u00edcio implemente a solu\u00e7\u00e3o no arquivo comb_modules.py e teste com pytest . A descri\u00e7\u00e3o do exerc\u00edcio est\u00e1 no pr\u00f3prio m\u00f3dulo. exe2() teste: pytest -k exe2 exe3() teste: pytest -k exe3 Progress Continuar... Executando na FPGA \u00b6 Agora vamos entender como conseguimos usar o nosso hardware descrito em MyHDL em um hardware real (FPGA), para isso temos que primeiro converter o MyHDL para VHDL e ent\u00e3o usar a ferramenta da Intel (Quartus) para sinterizar o nosso hardware. Depois disso temos que programar a FPGA, a seguir temos uma vis\u00e3o simplificada do fluxo: toplevel.py ---> toplevel.vhd ---> Makefile ---> .sof ---> FPGA ^ ^ | | componente.py Quartus Notem que agora o nosso m\u00f3dulo precisa ler e acionar pinos (interface com o mundo externo), normalmente a \u00faltima camada de um projeto de hardware (aquela que realmente acessa os pinos) \u00e9 chamada de toplevel. Os pinos dessa camada possuem nomes fixos, por isso temos que mapear os pinos do HW para os sinais do nosso m\u00f3dulo. Nessa primeira etapa iremos utilizar os seguintes componentes da nossa placa: Onde: LED : 10 leds que acendem com l\u00f3gica 1 Push Buttons : 4 bot\u00f5es que quando apertados fornecem l\u00f3gica 0 Slide Switchs : 10 Slides que quando acionados forcem l\u00f3gica 1 HEX Displays : 6 displays de 7 segmentos (anodo comum) Gerando toplevel.vhd \u00b6 O programa toplevel.py faz o mapeamento do componente para os pinos da FPGA e gera o arquivo toplevel.vhd que ser\u00e1 utilizado pelo Quartus para gerar o arquivo bin\u00e1rio que ir\u00e1 ser programado na FPGA, a ideia desse m\u00f3dulo \u00e9 mapear os sinais do componente para nomes e tamanhos fixos que ser\u00e3o utilizados pelo programa. toplevel.py @block def toplevel ( LEDR , SW , KEY , HEX0 , HEX1 , HEX2 , HEX3 , HEX4 , HEX5 , CLOCK_50 , RESET_N ): ... ic1 = exe4 ( ledr_s , SW ) ... # pinos LEDR = Signal ( intbv ( 0 )[ 10 :]) # (1) SW = Signal ( intbv ( 0 )[ 10 :]) KEY = Signal ( intbv ( 0 )[ 4 :]) HEX0 = Signal ( intbv ( 1 )[ 7 :]) HEX1 = Signal ( intbv ( 1 )[ 7 :]) HEX2 = Signal ( intbv ( 1 )[ 7 :]) HEX3 = Signal ( intbv ( 1 )[ 7 :]) HEX4 = Signal ( intbv ( 1 )[ 7 :]) HEX5 = Signal ( intbv ( 1 )[ 7 :]) # instance e generate vhd top = toplevel ( LEDR , SW , KEY , HEX0 , HEX1 , HEX2 , HEX3 , HEX4 , HEX5 ) top . convert ( hdl = \"VHDL\" ) # (2) Vetor de tamanho 10 Aqui indicamos para o MyHDL gerar o vhdl a partir do componente top Notem que os sinais criados s\u00e3o do tipo Signal(intbv(0)[X:]) , isso indica que estamos manipulando um vetor de bits de tamanho X , no caso do LED, indicamos que o vetor \u00e9 do tamanho 10, e no caso das KEY de tamanho 4. Com isso, podemos dentro do componente acessar individualmente cada um dos elementos do vetor: comb_modules.py @block def exe4 ( led , sw ): @always_comb def comb (): led [ 0 ] . next = sw [ 0 ] and ( not sw [ 1 ]) return instances () Info Notem que o componente recebe como argumentos os ledr_s e as chaves SW da FPGA e implementa a l\u00f3gica sw[0] and (not sw[1]) . Exercise Analise o arquivo toplevel.py Execute o toplevel.py e note a gera\u00e7\u00e3o do arquivo toplevel.vhd Analise o arquivo toplevel.vhd ./toplevel.py Gerando .sof \u00b6 O processo de gerar um hardware que posso ser executado na FPGA \u00e9 complexo e at\u00e9 pouco tempo n\u00e3o existiam ferramentas opensource que fazem isso. Iremos utilizar um software da Intel chamado de Quartus que \u00e9 capaz de sintetizar um hardware paras as FPGAs que a Intel possui, no nosso caso a Cyclone V. Para facilitar o desenvolvimento criamos um makefile que recebe como input a pasta do exerc\u00edcio e gera o sof . O projeto do quartus ser\u00e1 o mesmo para todos os exerc\u00edcios. Tip O processo \u00e9 demorado para quem est\u00e1 acostumado a apenas programar em python, a gerac\u00e3o do arquivo pode demorar alguns minutos. Exercise Na raiz do reposit\u00f3rio comb/quartus , execute: 1. make -C quartus clean 1. make -c quartus all 1. Aguardem compilar 1. Verifiquem que um novo arquivo quartus/DE0_CV_Default.sof foi gerado Programando FPGA \u00b6 Agora com a FPGA plugada no computador podemos programar, para isso usaremos o comando make program que deve enviar para a ROM da FPGA o bitstream. Exercise execute make program Mexa nas chaves 0 e 1 e notem o LED 0 obedece a equacao sw0 and (not sw1) Praticando - parte 2 \u00b6 Vamos praticar um pouco mais, agora usando a FPGA. Para cada um dos m\u00f3dulos a seguir, implemente o MyHDL e ent\u00e3o execute na FPGA. Exercise Modulo: exe5 Tarefa: Implementar o m\u00f3dulo Gerar o toplevel.vhd rodando toplevel.py Compile o vhdl make -C quartus clean make -C quartus all . make -C quartus program Validar na FPGA Exercise Modulo: sw2hex Modifique o toplevel.py adicionando o m\u00f3dulo novo para acionar o HEX0 controlado pelo sw2hex : ic1 = exe5(ledr_s, SW) +ic2 = sw2hex(HEX0, SW) Lembre de validar na FPGA. Exercise Modulo: bin2hex Modifique o toplevel.py adicionando o m\u00f3dulo novo para acionar o HEX1 controlado pelo bin2hex : ic1 = exe5(ledr_s, SW) ic2 = sw2hex(HEX0, SW) +ic3 = bin2hex(HEX1, SW) Lembre de validar na FPGA.","title":"Lab 5: MyHDL"},{"location":"class/comb-lab-1/#lab-5-myhdl","text":"Leitura pr\u00e9via necess\u00e1ria: MyHDL/MyHDL B\u00e1sico Teoria/FPGA (TODO) Este laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( L\u00f3gica-Combinacional ), onde iremos criar componentes de hardware que ser\u00e3o os alicerces do nosso computador. Primeiro precisamos praticar um pouco de MyHDL e entender a ferramenta e o fluxo de compila\u00e7\u00e3o, teste e como conseguimos executar o hardware em uma FPGA. Os exerc\u00edcios dos laborat\u00f3rios est\u00e3o localizados no reposit\u00f3rio: https://github.com/rafaelcorsi/bits-e-proc-labs , cada aluno de forma individual deve realizar um fork do reposit\u00f3rio e trabalhar individualmente nele. Os laborat\u00f3rios n\u00e3o po ffssuem entregas, mas devem ser realizados para estudo. Exercise Realize um fork do reposit\u00f3rio de labs Clone o reposit\u00f3rio para a sua m\u00e1quina Exercise N\u00f3s iremos trabalhar sempre com um ambiente virtual do python 3.8, para isso ser\u00e1 necess\u00e1rio realizar as seguintes opera\u00e7\u00f5es dentro da pasta clonada : python3.8 -m venv env . env/bin/activate pip3 install -r requirements.txt Warning Sempre que for abrir um terminal novo e acessar a pasta, ser\u00e1 necess\u00e1rio ativar o ambiente virtual: . env/bin/activate Se for utilizar o VSCODE para fazer o desenvolvimento dos projetos e exerc\u00edcios, basta abrir a pasta raiz do reposit\u00f3rio que o code j\u00e1 utiliza o ambiente virtual (eu criei o arquivo .vscode/settings.json que configura isso.)","title":"Lab 5: MyHDL"},{"location":"class/comb-lab-1/#pytest","text":"Bits e Processadores utiliza uma metodologia de desenvolvimento de projeto chamada de test driven development (TDD) , ou seja, para cada etapa do projeto teremos um teste associado a ele. Os testes podem ser do tipo unit\u00e1rio e de integra\u0107\u00e3o. Para realizarmos os testes em python utilizaremos o m\u00f3dulo pytest e o plugin de dev-life (para fazer o report do progresso de voc\u00eas para o servidor). Cada exerc\u00edcio possui um arquivo com o prefixo test_ que excita o componente que voc\u00eas ir\u00e3o desenvolver e valida a sa\u00edda esperada. A seguir um exemplo do teste falhando e ent\u00e3o solucionado e testado novamente: Exercise Navegue no terminal at\u00e9 a pasta comb Execute no terminal pytest -k exe1 O teste deve falhar pois n\u00e3o foi implementado ainda. Edite o arquivo comb_modules.py com a l\u00f3gica a seguir: def exe1(): - pass + q.next = a or (and b) Execute o pytest novamente e note que o c\u00f3digo passa no teste. Info Todo o teste executado no reposit\u00f3rio ser\u00e1 submetido ao servidor de dev-life para processamento futuro e acompanhamento individual da participac\u00e3o de voc\u00eas nos projetos. Portanto, facam individualmente os laborat\u00f3rios. Progress Come\u00e7ando o laborat\u00f3rio.","title":"pytest"},{"location":"class/comb-lab-1/#praticando-parte-1","text":"Vamos comecar descrevendo algumas circuitos l\u00f3gicos combinacionais bem simples em MyHDL. Exercise Para cada exerc\u00edcio implemente a solu\u00e7\u00e3o no arquivo comb_modules.py e teste com pytest . A descri\u00e7\u00e3o do exerc\u00edcio est\u00e1 no pr\u00f3prio m\u00f3dulo. exe2() teste: pytest -k exe2 exe3() teste: pytest -k exe3 Progress Continuar...","title":"Praticando - Parte 1"},{"location":"class/comb-lab-1/#executando-na-fpga","text":"Agora vamos entender como conseguimos usar o nosso hardware descrito em MyHDL em um hardware real (FPGA), para isso temos que primeiro converter o MyHDL para VHDL e ent\u00e3o usar a ferramenta da Intel (Quartus) para sinterizar o nosso hardware. Depois disso temos que programar a FPGA, a seguir temos uma vis\u00e3o simplificada do fluxo: toplevel.py ---> toplevel.vhd ---> Makefile ---> .sof ---> FPGA ^ ^ | | componente.py Quartus Notem que agora o nosso m\u00f3dulo precisa ler e acionar pinos (interface com o mundo externo), normalmente a \u00faltima camada de um projeto de hardware (aquela que realmente acessa os pinos) \u00e9 chamada de toplevel. Os pinos dessa camada possuem nomes fixos, por isso temos que mapear os pinos do HW para os sinais do nosso m\u00f3dulo. Nessa primeira etapa iremos utilizar os seguintes componentes da nossa placa: Onde: LED : 10 leds que acendem com l\u00f3gica 1 Push Buttons : 4 bot\u00f5es que quando apertados fornecem l\u00f3gica 0 Slide Switchs : 10 Slides que quando acionados forcem l\u00f3gica 1 HEX Displays : 6 displays de 7 segmentos (anodo comum)","title":"Executando na FPGA"},{"location":"class/comb-lab-1/#gerando-toplevelvhd","text":"O programa toplevel.py faz o mapeamento do componente para os pinos da FPGA e gera o arquivo toplevel.vhd que ser\u00e1 utilizado pelo Quartus para gerar o arquivo bin\u00e1rio que ir\u00e1 ser programado na FPGA, a ideia desse m\u00f3dulo \u00e9 mapear os sinais do componente para nomes e tamanhos fixos que ser\u00e3o utilizados pelo programa. toplevel.py @block def toplevel ( LEDR , SW , KEY , HEX0 , HEX1 , HEX2 , HEX3 , HEX4 , HEX5 , CLOCK_50 , RESET_N ): ... ic1 = exe4 ( ledr_s , SW ) ... # pinos LEDR = Signal ( intbv ( 0 )[ 10 :]) # (1) SW = Signal ( intbv ( 0 )[ 10 :]) KEY = Signal ( intbv ( 0 )[ 4 :]) HEX0 = Signal ( intbv ( 1 )[ 7 :]) HEX1 = Signal ( intbv ( 1 )[ 7 :]) HEX2 = Signal ( intbv ( 1 )[ 7 :]) HEX3 = Signal ( intbv ( 1 )[ 7 :]) HEX4 = Signal ( intbv ( 1 )[ 7 :]) HEX5 = Signal ( intbv ( 1 )[ 7 :]) # instance e generate vhd top = toplevel ( LEDR , SW , KEY , HEX0 , HEX1 , HEX2 , HEX3 , HEX4 , HEX5 ) top . convert ( hdl = \"VHDL\" ) # (2) Vetor de tamanho 10 Aqui indicamos para o MyHDL gerar o vhdl a partir do componente top Notem que os sinais criados s\u00e3o do tipo Signal(intbv(0)[X:]) , isso indica que estamos manipulando um vetor de bits de tamanho X , no caso do LED, indicamos que o vetor \u00e9 do tamanho 10, e no caso das KEY de tamanho 4. Com isso, podemos dentro do componente acessar individualmente cada um dos elementos do vetor: comb_modules.py @block def exe4 ( led , sw ): @always_comb def comb (): led [ 0 ] . next = sw [ 0 ] and ( not sw [ 1 ]) return instances () Info Notem que o componente recebe como argumentos os ledr_s e as chaves SW da FPGA e implementa a l\u00f3gica sw[0] and (not sw[1]) . Exercise Analise o arquivo toplevel.py Execute o toplevel.py e note a gera\u00e7\u00e3o do arquivo toplevel.vhd Analise o arquivo toplevel.vhd ./toplevel.py","title":"Gerando toplevel.vhd"},{"location":"class/comb-lab-1/#gerando-sof","text":"O processo de gerar um hardware que posso ser executado na FPGA \u00e9 complexo e at\u00e9 pouco tempo n\u00e3o existiam ferramentas opensource que fazem isso. Iremos utilizar um software da Intel chamado de Quartus que \u00e9 capaz de sintetizar um hardware paras as FPGAs que a Intel possui, no nosso caso a Cyclone V. Para facilitar o desenvolvimento criamos um makefile que recebe como input a pasta do exerc\u00edcio e gera o sof . O projeto do quartus ser\u00e1 o mesmo para todos os exerc\u00edcios. Tip O processo \u00e9 demorado para quem est\u00e1 acostumado a apenas programar em python, a gerac\u00e3o do arquivo pode demorar alguns minutos. Exercise Na raiz do reposit\u00f3rio comb/quartus , execute: 1. make -C quartus clean 1. make -c quartus all 1. Aguardem compilar 1. Verifiquem que um novo arquivo quartus/DE0_CV_Default.sof foi gerado","title":"Gerando .sof"},{"location":"class/comb-lab-1/#programando-fpga","text":"Agora com a FPGA plugada no computador podemos programar, para isso usaremos o comando make program que deve enviar para a ROM da FPGA o bitstream. Exercise execute make program Mexa nas chaves 0 e 1 e notem o LED 0 obedece a equacao sw0 and (not sw1)","title":"Programando FPGA"},{"location":"class/comb-lab-1/#praticando-parte-2","text":"Vamos praticar um pouco mais, agora usando a FPGA. Para cada um dos m\u00f3dulos a seguir, implemente o MyHDL e ent\u00e3o execute na FPGA. Exercise Modulo: exe5 Tarefa: Implementar o m\u00f3dulo Gerar o toplevel.vhd rodando toplevel.py Compile o vhdl make -C quartus clean make -C quartus all . make -C quartus program Validar na FPGA Exercise Modulo: sw2hex Modifique o toplevel.py adicionando o m\u00f3dulo novo para acionar o HEX0 controlado pelo sw2hex : ic1 = exe5(ledr_s, SW) +ic2 = sw2hex(HEX0, SW) Lembre de validar na FPGA. Exercise Modulo: bin2hex Modifique o toplevel.py adicionando o m\u00f3dulo novo para acionar o HEX1 controlado pelo bin2hex : ic1 = exe5(ledr_s, SW) ic2 = sw2hex(HEX0, SW) +ic3 = bin2hex(HEX1, SW) Lembre de validar na FPGA.","title":"Praticando - parte 2"},{"location":"class/comb-projeto/","text":"B - L\u00f3gica Combinacional \u00b6 Data da entrega ?? Arquivo: hw/components.py Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e MyHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador. Instru\u00e7\u00f5es \u00b6 O desenvolvimento ser\u00e1 na linguagem MyHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo. Integrantes \u00b6 Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual. Controle de Tarefas e Reposit\u00f3rio \u00b6 Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado. Facilitador (Scrum Master) Desenvolvedores Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests Testes CI \u00b6 Cada desenvolvedor al\u00e9m de editar o arquivo hw/components.py deve editar o arquivo .github/ .... Entrega \u00b6 A entrega final deve ser feita no ramo master do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Actions deve estar configurado e funcionando Conceito C+ \u00b6 AND 16 bits block : and16 Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits block : or8way Descri\u00e7\u00e3o : OR entre as 8 entradas. OR 8 Way block : or8way Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Barrel Shifter block : barrelShifter Descri\u00e7\u00e3o : Demultiplexador de 2 sa\u00eddas block : DMux2Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexador de 4 sa\u00eddas block : DMux4Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexador de 8 sa\u00eddas block : DMux8Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits block : Mux16. Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada block : Mux2Way. Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada block : Mux4Way. Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada block : Mux8Way. Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada block : Mux4Way16. Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada block : Mux8Way16 Deslocador de bits block : BarrelShifter16.vhd Conceito B+ \u00b6 Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA. Rubricas para avalia\u00e7\u00e3o do projeto \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo. Grupo \u00b6 Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A+ Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA - anexar video ao reposit\u00f3rio (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) B+ M\u00f3dulos adicionais implementados e funcionado (circuito, detector de moedas, impressora) Implementar um \u00fanico display de 7s (conta de 0x0 0xF) - anexar video ao reposit\u00f3rio C+ Ter criado o project no github Actions configurado e funcionando Todos os m\u00f3dulos b\u00e1sicos implementados e funcionado D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha Individual \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"B - L\u00f3gica Combinacional"},{"location":"class/comb-projeto/#b-logica-combinacional","text":"Data da entrega ?? Arquivo: hw/components.py Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e MyHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador.","title":"B - L\u00f3gica Combinacional"},{"location":"class/comb-projeto/#instrucoes","text":"O desenvolvimento ser\u00e1 na linguagem MyHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo.","title":"Instru\u00e7\u00f5es"},{"location":"class/comb-projeto/#integrantes","text":"Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual.","title":"Integrantes"},{"location":"class/comb-projeto/#controle-de-tarefas-e-repositorio","text":"Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado. Facilitador (Scrum Master) Desenvolvedores Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests","title":"Controle de Tarefas e Reposit\u00f3rio"},{"location":"class/comb-projeto/#testes-ci","text":"Cada desenvolvedor al\u00e9m de editar o arquivo hw/components.py deve editar o arquivo .github/ ....","title":"Testes CI"},{"location":"class/comb-projeto/#entrega","text":"A entrega final deve ser feita no ramo master do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Actions deve estar configurado e funcionando","title":"Entrega"},{"location":"class/comb-projeto/#conceito-c","text":"AND 16 bits block : and16 Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits block : or8way Descri\u00e7\u00e3o : OR entre as 8 entradas. OR 8 Way block : or8way Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Barrel Shifter block : barrelShifter Descri\u00e7\u00e3o : Demultiplexador de 2 sa\u00eddas block : DMux2Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexador de 4 sa\u00eddas block : DMux4Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexador de 8 sa\u00eddas block : DMux8Way. Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits block : Mux16. Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada block : Mux2Way. Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada block : Mux4Way. Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada block : Mux8Way. Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada block : Mux4Way16. Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada block : Mux8Way16 Deslocador de bits block : BarrelShifter16.vhd","title":"Conceito C+"},{"location":"class/comb-projeto/#conceito-b","text":"Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA.","title":"Conceito B+"},{"location":"class/comb-projeto/#rubricas-para-avaliacao-do-projeto","text":"Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo.","title":"Rubricas para avalia\u00e7\u00e3o do projeto"},{"location":"class/comb-projeto/#grupo","text":"Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A+ Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA - anexar video ao reposit\u00f3rio (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) B+ M\u00f3dulos adicionais implementados e funcionado (circuito, detector de moedas, impressora) Implementar um \u00fanico display de 7s (conta de 0x0 0xF) - anexar video ao reposit\u00f3rio C+ Ter criado o project no github Actions configurado e funcionando Todos os m\u00f3dulos b\u00e1sicos implementados e funcionado D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha","title":"Grupo"},{"location":"class/comb-projeto/#individual","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Individual"},{"location":"class/comb-projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"class/intro-benchmark-lab/","text":"Lab 1: Benchmark \u00b6 pensadeira Forncer um ssd com a infra j\u00e1 instalada? Rodar testes no monstr\u00e3o/ aws/ rasp3/ rasp4 Quais tipos de benchmark? processamento cache acesso a disco Warning Conecte o seu computador na tomada. Neste laborat\u00f3rio iremos explorar os diferentes tipos de hardware existentes e qual o impacto no desempenho de alguns tipos de programa. Para isso iremos utilizar o phoronix-test-suite , que disponibiliza uma s\u00e9rie de testes do https://openbenchmarking.org/ . pre-lab \u00b6 Instale o Phoronix Text Suite . Ubuntu: wget https://github.com/phoronix-test-suite/phoronix-test-suite/releases/download/v10.8.3/phoronix-test-suite_10.8.3_all.deb phoronix.deb sudo dpkg -i phoronix.deb sudo apt install -f Mac: brew install phoronix-test-suite Windows: Instale o xampp (servidor PHP) https://www.apachefriends.org/pt_br/index.html Baixe o zip do phoronix e extraia os arquivos: https://github.com/phoronix-test-suite/phoronix-test-suite/releases/download/v10.8.3/phoronix-test-suite-10.8.3.tar.gz Execute o phoronix-test-suite.bat configurando \u00b6 No terminal, execute: phoronix-test-suite batch-setup E configure como indicado a seguir: Save test results when in batch mode (Y/n): n Open the web browser automatically when in batch mode (y/N): y Auto upload the results to OpenBenchmarking.org (Y/n): n Prompt for test identifier (Y/n): n Prompt for test description (Y/n): n Prompt for saved results file-name (Y/n): n Run all test options (Y/n): y Informac\u00e3o do sistema \u00b6 Agora vamos extrair algumas informa\u00e7\u00f5es do sistema, para isso execute no terminal: phoronix-test-suite system-properties Voc\u00ea deve obter uma lista com informa\u00e7\u00f5es detalhadas do seu sistema, com os dados preencha a tabela a seguir: Exercise A tabela pede informa\u00e7\u00f5es extras sobre o seu disco r\u00edgido, sugerimos voc\u00ea procurar no google usando como base o modelo que foi fornecido pelo phoronix. Remova da busca a capacidade do disco, isso pode atrapalhar. No Linux para saber mais sobre o seu hardware instale: sudo apt install hardinfo Caso n\u00e3o encontre todas as informa\u00e7\u00f5es tudo bem! https://docs.google.com/spreadsheets/d/1-wJcqGsZMZzgkiVMG4cb2BI__cL7_cRLNCoCHIYf-GA/edit?usp=sharing Executando o primeiro teste \u00b6 Vamos executar o primeiro teste, que envolve compilar o kernel do Linux: Tip O teste deve demorar alguns minutos: phoronix-test-suite benchmark build-linux-kernel Testes \u00b6 Agora vamos come\u00e7ar executar uma s\u00e9rie de testes no computador de voc\u00eas, cada teste vai excitar uma ou v\u00e1rias partes do hardware. Ap\u00f3s realizado o teste voc\u00ea deve copiar o resultado para a tabela. Tip Enquanto voc\u00ea aguarda a execu\u00e7\u00e3o dos testes, de uma olhada no system monitor do seu computador, o que tem acontecido com os recursos de hardware? CPU, mem\u00f3ria, disco.... Exercise Benchmark de codificar \u00e1udio no formato flac , quanto menor o tempo melhor! phoronix-test-suite benchmark pts/encode-flac Preencha a tabela com o resultado. Para cada um dos benchmarks o sistema ir\u00e1 fazer a instala\u00e7\u00e3o dos arquivos necess\u00e1rios e ent\u00e3o executar automaticamente o teste, gerando um log no final que ser\u00e1 exibido em uma p\u00e1gina web. Exercise Benchmark de comprimir arquivos com o gzip , quanto menor o tempo melhor! phoronix-test-suite benchmark compress-gzip Preencha a tabela com o resultado. Exercise Benchmark de acesso a mem\u00f3ria, maior o valor melhor! phoronix-test-suite benchmark cachebench Preencha a tabela com o resultado. Exercise Benchmark de acesso a mem\u00f3ria, maior o valor melhor! phoronix-test-suite benchmark stream Preencha a tabela com o resultado. Exercise phoronix-test-suite benchmark aircrack-ng Preencha a tabela com o resultado.","title":"Lab 1: Benchmark"},{"location":"class/intro-benchmark-lab/#lab-1-benchmark","text":"pensadeira Forncer um ssd com a infra j\u00e1 instalada? Rodar testes no monstr\u00e3o/ aws/ rasp3/ rasp4 Quais tipos de benchmark? processamento cache acesso a disco Warning Conecte o seu computador na tomada. Neste laborat\u00f3rio iremos explorar os diferentes tipos de hardware existentes e qual o impacto no desempenho de alguns tipos de programa. Para isso iremos utilizar o phoronix-test-suite , que disponibiliza uma s\u00e9rie de testes do https://openbenchmarking.org/ .","title":"Lab 1: Benchmark"},{"location":"class/intro-benchmark-lab/#pre-lab","text":"Instale o Phoronix Text Suite . Ubuntu: wget https://github.com/phoronix-test-suite/phoronix-test-suite/releases/download/v10.8.3/phoronix-test-suite_10.8.3_all.deb phoronix.deb sudo dpkg -i phoronix.deb sudo apt install -f Mac: brew install phoronix-test-suite Windows: Instale o xampp (servidor PHP) https://www.apachefriends.org/pt_br/index.html Baixe o zip do phoronix e extraia os arquivos: https://github.com/phoronix-test-suite/phoronix-test-suite/releases/download/v10.8.3/phoronix-test-suite-10.8.3.tar.gz Execute o phoronix-test-suite.bat","title":"pre-lab"},{"location":"class/intro-benchmark-lab/#configurando","text":"No terminal, execute: phoronix-test-suite batch-setup E configure como indicado a seguir: Save test results when in batch mode (Y/n): n Open the web browser automatically when in batch mode (y/N): y Auto upload the results to OpenBenchmarking.org (Y/n): n Prompt for test identifier (Y/n): n Prompt for test description (Y/n): n Prompt for saved results file-name (Y/n): n Run all test options (Y/n): y","title":"configurando"},{"location":"class/intro-benchmark-lab/#informacao-do-sistema","text":"Agora vamos extrair algumas informa\u00e7\u00f5es do sistema, para isso execute no terminal: phoronix-test-suite system-properties Voc\u00ea deve obter uma lista com informa\u00e7\u00f5es detalhadas do seu sistema, com os dados preencha a tabela a seguir: Exercise A tabela pede informa\u00e7\u00f5es extras sobre o seu disco r\u00edgido, sugerimos voc\u00ea procurar no google usando como base o modelo que foi fornecido pelo phoronix. Remova da busca a capacidade do disco, isso pode atrapalhar. No Linux para saber mais sobre o seu hardware instale: sudo apt install hardinfo Caso n\u00e3o encontre todas as informa\u00e7\u00f5es tudo bem! https://docs.google.com/spreadsheets/d/1-wJcqGsZMZzgkiVMG4cb2BI__cL7_cRLNCoCHIYf-GA/edit?usp=sharing","title":"Informac\u00e3o do sistema"},{"location":"class/intro-benchmark-lab/#executando-o-primeiro-teste","text":"Vamos executar o primeiro teste, que envolve compilar o kernel do Linux: Tip O teste deve demorar alguns minutos: phoronix-test-suite benchmark build-linux-kernel","title":"Executando o primeiro teste"},{"location":"class/intro-benchmark-lab/#testes","text":"Agora vamos come\u00e7ar executar uma s\u00e9rie de testes no computador de voc\u00eas, cada teste vai excitar uma ou v\u00e1rias partes do hardware. Ap\u00f3s realizado o teste voc\u00ea deve copiar o resultado para a tabela. Tip Enquanto voc\u00ea aguarda a execu\u00e7\u00e3o dos testes, de uma olhada no system monitor do seu computador, o que tem acontecido com os recursos de hardware? CPU, mem\u00f3ria, disco.... Exercise Benchmark de codificar \u00e1udio no formato flac , quanto menor o tempo melhor! phoronix-test-suite benchmark pts/encode-flac Preencha a tabela com o resultado. Para cada um dos benchmarks o sistema ir\u00e1 fazer a instala\u00e7\u00e3o dos arquivos necess\u00e1rios e ent\u00e3o executar automaticamente o teste, gerando um log no final que ser\u00e1 exibido em uma p\u00e1gina web. Exercise Benchmark de comprimir arquivos com o gzip , quanto menor o tempo melhor! phoronix-test-suite benchmark compress-gzip Preencha a tabela com o resultado. Exercise Benchmark de acesso a mem\u00f3ria, maior o valor melhor! phoronix-test-suite benchmark cachebench Preencha a tabela com o resultado. Exercise Benchmark de acesso a mem\u00f3ria, maior o valor melhor! phoronix-test-suite benchmark stream Preencha a tabela com o resultado. Exercise phoronix-test-suite benchmark aircrack-ng Preencha a tabela com o resultado.","title":"Testes"},{"location":"class/intro-lab-1/","text":"Lab 2: Configurando Github \u00b6 Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de 4 colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas. Exercise Ap\u00f3s criarem os grupos, preencham a tabela a seguir: https://docs.google.com/spreadsheets/d/1eb_euZeNXjk3d51_2NCpdM_xwvyj-cBYoPgfGHtwfOQ/edit?usp=sharing GitHub \u00b6 O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores. Fork \u00b6 Uma pessoa por grupo Daqui at\u00e9 o final s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. O Scrum Master do grupo (escolham entre voc\u00eas) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/bits-e-proc E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original ( /insper/bits-e-proc ) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git fork n\u00e3o existe no git, \u00e9 algo implementado pelo github (e similares). \u00c9 utilizado para criar uma 'c\u00f3pia' de um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original. Exercise Crie um fork do reposit\u00f3rio original Alterando o nome do Fork Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : bits-e-proc-NomeDoGrupo O Nome do grupo deve ser uma palavra que come\u00e7e com a letra que o grupo recebeu... Progress Cheguei Aqui! Colaboradores \u00b6 Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Todos integrantes do grupo j\u00e1 devem ter uma conta no github j\u00e1 criada. Progress Cheguei Aqui! Exercise Adicionar todos os membros como owner do reposit\u00f3rio. Ferramentas github \u00b6 git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Ferramentas github Outras ferramentas do github/ git que iremos usar: Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Main : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o. Exercise Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings Features e ative Issues e Project . Actions \u00b6 Ir\u00e1 executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github. Como ele funciona? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no nosso caso: python, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o est\u00e1 localizado na pasta do reposit\u00f3rio .github/workflows/ \u00e9 nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina web do seu reposit\u00f3rio no github em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente. Arquivo GRUPO.json de configura\u00e7\u00e3o \u00b6 Um por grupo Somente um do grupo deve realizar isso. Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { Nome-Grupo: \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin main Exercise Editar localmente o arquivo GRUPO.yml , apenas no NOME-DO-GRUPO","title":"Lab 2: Configurando Github"},{"location":"class/intro-lab-1/#lab-2-configurando-github","text":"Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de 4 colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas. Exercise Ap\u00f3s criarem os grupos, preencham a tabela a seguir: https://docs.google.com/spreadsheets/d/1eb_euZeNXjk3d51_2NCpdM_xwvyj-cBYoPgfGHtwfOQ/edit?usp=sharing","title":"Lab 2: Configurando Github"},{"location":"class/intro-lab-1/#github","text":"O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores.","title":"GitHub"},{"location":"class/intro-lab-1/#fork","text":"Uma pessoa por grupo Daqui at\u00e9 o final s\u00f3 uma pessoa do grupo deve fazer! Os demais devem acompanhar. O Scrum Master do grupo (escolham entre voc\u00eas) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/bits-e-proc E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original ( /insper/bits-e-proc ) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git fork n\u00e3o existe no git, \u00e9 algo implementado pelo github (e similares). \u00c9 utilizado para criar uma 'c\u00f3pia' de um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original. Exercise Crie um fork do reposit\u00f3rio original Alterando o nome do Fork Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : bits-e-proc-NomeDoGrupo O Nome do grupo deve ser uma palavra que come\u00e7e com a letra que o grupo recebeu... Progress Cheguei Aqui!","title":"Fork"},{"location":"class/intro-lab-1/#colaboradores","text":"Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Todos integrantes do grupo j\u00e1 devem ter uma conta no github j\u00e1 criada. Progress Cheguei Aqui! Exercise Adicionar todos os membros como owner do reposit\u00f3rio.","title":"Colaboradores"},{"location":"class/intro-lab-1/#ferramentas-github","text":"git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Ferramentas github Outras ferramentas do github/ git que iremos usar: Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Main : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o. Exercise Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings Features e ative Issues e Project .","title":"Ferramentas github"},{"location":"class/intro-lab-1/#actions","text":"Ir\u00e1 executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github. Como ele funciona? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no nosso caso: python, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o est\u00e1 localizado na pasta do reposit\u00f3rio .github/workflows/ \u00e9 nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina web do seu reposit\u00f3rio no github em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente.","title":"Actions"},{"location":"class/intro-lab-1/#arquivo-grupojson-de-configuracao","text":"Um por grupo Somente um do grupo deve realizar isso. Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { Nome-Grupo: \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin main Exercise Editar localmente o arquivo GRUPO.yml , apenas no NOME-DO-GRUPO","title":"Arquivo GRUPO.json de configura\u00e7\u00e3o"},{"location":"class/intro-lab-2/","text":"Lab 3: Github \u00b6 Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows (precisa ter git instalado). Clonando \u00b6 Individual Todos do grupo devem realizar de maneira individual! Uma vez criado o fork e adicionado os colegas como contribuidores do projeto (feito no lab 1) voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone $URL_DO_FORK $URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github Note que a url exibida \u00e9 do reposit\u00f3rio base da disciplina, voc\u00eas devem clonar o reposit\u00f3rio que foi criado no Lab 1 Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal no Linux: meta + t Progress Cheguei Aqui! Adicionando nomes ao GRUPO.yml \u00b6 Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remoto $ git pull origin main Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: - user: 1 name: Rafael Corsi git-username: rafael.corsi blackboard-username: rafael.ferrao Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador. Progress Cheguei Aqui! branch / commit \u00b6 A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add GRUPO.yml $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Progress Cheguei Aqui! Realizando pull-request \u00b6 Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a p\u00e1gina do github do seu grupo. Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Actions ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Actions. Progress Cheguei Aqui! Aceitando pull-request \u00b6 Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! Projetar no monitor para que todos acompanhem o processo O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Lab 3: Github"},{"location":"class/intro-lab-2/#lab-3-github","text":"Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows (precisa ter git instalado).","title":"Lab 3: Github"},{"location":"class/intro-lab-2/#clonando","text":"Individual Todos do grupo devem realizar de maneira individual! Uma vez criado o fork e adicionado os colegas como contribuidores do projeto (feito no lab 1) voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone $URL_DO_FORK $URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github Note que a url exibida \u00e9 do reposit\u00f3rio base da disciplina, voc\u00eas devem clonar o reposit\u00f3rio que foi criado no Lab 1 Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal no Linux: meta + t Progress Cheguei Aqui!","title":"Clonando"},{"location":"class/intro-lab-2/#adicionando-nomes-ao-grupoyml","text":"Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remoto $ git pull origin main Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: - user: 1 name: Rafael Corsi git-username: rafael.corsi blackboard-username: rafael.ferrao Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador. Progress Cheguei Aqui!","title":"Adicionando nomes ao GRUPO.yml"},{"location":"class/intro-lab-2/#branch-commit","text":"A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add GRUPO.yml $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Progress Cheguei Aqui!","title":"branch / commit"},{"location":"class/intro-lab-2/#realizando-pull-request","text":"Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a p\u00e1gina do github do seu grupo. Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Actions ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Actions. Progress Cheguei Aqui!","title":"Realizando pull-request"},{"location":"class/intro-lab-2/#aceitando-pull-request","text":"Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! Projetar no monitor para que todos acompanhem o processo O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Aceitando pull-request"},{"location":"class/intro-projeto/","text":"A - Ambiente de desenvolvimento \u00b6 Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Teams Actions Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab 1: Configurando Github Lab 2: Github Rubricas \u00b6 Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I . Grupo \u00b6 Para a entrega ser aceita: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Integrantes do grupo realizaram pull-request e os mesmos foram aceitos Ter criado um canal dentro no Teams da disciplina Individual \u00b6 Para a entrega individual ser aceita: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal da disciplina (teams) Ter entrado no canal do grupo (teams)","title":"A - Ambiente de desenvolvimento"},{"location":"class/intro-projeto/#a-ambiente-de-desenvolvimento","text":"Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Teams Actions Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab 1: Configurando Github Lab 2: Github","title":"A - Ambiente de desenvolvimento"},{"location":"class/intro-projeto/#rubricas","text":"Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I .","title":"Rubricas"},{"location":"class/intro-projeto/#grupo","text":"Para a entrega ser aceita: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Integrantes do grupo realizaram pull-request e os mesmos foram aceitos Ter criado um canal dentro no Teams da disciplina","title":"Grupo"},{"location":"class/intro-projeto/#individual","text":"Para a entrega individual ser aceita: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal da disciplina (teams) Ter entrado no canal do grupo (teams)","title":"Individual"},{"location":"class/logSeq-lab-1/","text":"Document Title \u00b6","title":"Document Title"},{"location":"class/logSeq-lab-1/#document-title","text":"","title":"Document Title"},{"location":"class/seq-lab-1/","text":"Lab 8: L\u00f3gica Sequencial \u00b6 Agora vamos ver como implementamos uma l\u00f3gica sequencia em MyHDL! At\u00e9 agora temos utilizado o decorator : @always_comb para indicar que uma fun\u00e7\u00e3o deve ser interpretada como um trecho combinacional: @always_comb def comb (): led . next = l Agora vamos come\u00e7ar usar um novo decorator ( @always_seq ) para indicar que uma fun\u00e7\u00e3o deve ser sequencial e depender do clock e do reset . O m\u00f3dulo aseguir demonstra como implementar um flip-flop tipo D em MyHDL: @block def dff ( q , d , clk , rst ): @always_seq ( clk . posedge , reset = rst ) def seq (): q . next = d return instances () Notem que estamos usando @always_seq(clk.posedge, reset=rst) , e indicando que o m\u00f3dulo deve ser acionado na borda de subida do sinal clk e que o sinal de reset deve ser o rst . Podemos interpretar o def seq() da seguinte maneira: Sempre que o sinal clock variar de 0 para 1 a fun\u00e7\u00e3o \u00e9 acionada e ent\u00e3o a sa\u00edda q recebe a entrada d . Podemos visualizar isso como um while True: while True : q . next = d time . sleep ( 1 / CLOCK ) dff \u00b6 Exercise File: seq/seq_modules.py Tarefa: Vamos validar o flip-flop, para isso modifique o toplevel.py : ic0 = dff ( ledr_s [ 0 ], sw_s [ 0 ], key_s [ 0 ], RESET_N ) E fa\u00e7a o processo completo para obtermos o hardware. Validando: Mapeamos o clock para o KEY[0] e a entrada do dff para o SW[0] , notem que ao mexer a chave SW[0] nada acontece, o valor do LED muda apenas ap\u00f3s apertar o KEY[0] (que \u00e9 o clock ) Clock \u00b6 O sinal de clock da nossa FPGA \u00e9 de 50Mhz , ou seja: 50 000 000 vezes por segundo! Isso parece muito n\u00e9? Mas, dependendo do projeto, podemos elevar o clock para 200Mhz ou usar FPGAs mais r\u00e1pidas que chegam pr\u00f3ximo do 1GHz. Piscando LED \u00b6 Agora com o uso da l\u00f3gica sequencial conseguimos contar 'tempo' e gerar eventos em determinado momento. Ou seja: podemos contar 0.5 segundos e mudar o valor do led, contar mais 0.5 s e mudar novamente (fazer o famoso pisca led ). Para isso, teremos que conseguir contar eventos de clock, e quando o valor chegar em 25 000 000 inverter o valor do LED e zerar o contador e ficar nesse loop para sempre. Podemos usar o nosso adder do lab anterior como m\u00f3dulo de contador, conectando a sa\u00edda do adder na entrada x , mas passando por um registrador antes (para apenas mudar a cada clock). A entrada y ser\u00e1 conectado ao valor 1 , como resultado teremos: s = x + 1 . A express\u00e3o ser\u00e1 executada a cada subida do clock. E x ser\u00e1: if s < MAX : x . next = s else : x . next = 0 Se o valor de s for menor que o valor m\u00e1ximo (define a velocidade que o LED ir\u00e1 piscar) copiamos a sa\u00edda do somador para a entrada, e se o valor MAX for atingido, iremos zerar o somador, para come\u00e7armos novamente. O HW que queremos gerar \u00e9 algo como: A implementa\u00e7\u00e3o em MyHDL: @block def blinkLedAdder ( led , clk , rst ): x = [ Signal ( bool ( 0 )) for i in range ( 32 )] y = [ Signal ( bool ( 0 )) for i in range ( 32 )] s = [ Signal ( bool ( 0 )) for i in range ( 32 )] c = Signal ( bool ( 0 )) status = Signal ( bool ( 0 )) y [ 0 ] = 1 adder_1 = adder ( x , y , s , c ) @always_seq ( clk . posedge , reset = rst ) def seq (): if x [ 21 ] == 0 : for i in range ( len ( x )): x [ i ] . next = s [ i ] status . next = status else : for i in range ( len ( x )): x [ i ] . next = 0 status . next = not status @always_comb def comb (): led . next = status return instances () Exercise File: toplevel.py Modifiquem o toplevel para conter o componente: ic1 = blinkLedAdder ( ledr_s [ 0 ], CLOCK_50 , RESET_N ) E fa\u00e7am o fluxo de rodar o m\u00f3dulo na FPGA. Verifiquem que o LED pisca!! Alguns detalhes devem ser levados em considera\u00e7\u00e3o na implementa\u00e7\u00e3o do componente: Estamos lidando com vetores de bit, que devem ser acessados individualmente O seq acontece a cada mudan\u00e7a do clock O comb acontece sempre N\u00e3o podemos ler uma sa\u00edda - if s < MAX: + if x[24] == 0 and x[23] == 0: Temos que lembrar que estamos lidando com um vetor de bits que n\u00e3o possuem liga\u00e7\u00e3o entre si, ent\u00e3o n\u00e3o podemos fazer uma compara\u00e7\u00e3o como se eles fossem um inteiro: if x < 25000000 , mas temos que verificar os bits individualmente. Nesse caso eu estou verificando se os bits 24 e 23 s\u00e3o iguais a zero. Pois: 2^24 + 2^23 = 25165824 Um valor muito pr\u00f3ximo de 25M (um erro menor que 1%). Que para o pisca led n\u00e3o ser\u00e1 percept\u00edvel. Poder\u00edamos \u00e9 claro melhorar colocando mais bits na verifica\u00e7\u00e3o, mas n\u00e3o \u00e9 necess\u00e1rio. Por conta de x e s serem vetores, temos que fazer uma varredura para atribuirmos cada um dos index: - x.next = s + for i in range(len(x)): + x[i].next = s[i] Warning \u00c9 importante sabermos que o for em hardware n\u00e3o existe, \u00e9 apenas um recurso para facilitar a descri\u00e7\u00e3o do componente, no lugar de escrevermos isso: x[0].next = s[0] x[1].next = s[1] ... A ideia de piscar o LED \u00e9 que temos que mudar uma vari\u00e1vel a cada ciclo do contador. ----------- ------------- | | | Status | | | ----------- ---------- _ 25000000 _ _ / | / | / | / | / | / | Contador / | / | / | / |/ | / | Mas como o sinal led \u00e9 uma sa\u00edda, n\u00e3o podemos acessar ele diretamente. Para isso, eu criei um sinal interno auxiliar status que \u00e9 alterado sempre que o contador \u00e9 zerado: def seq (): if x [ 24 ] == 0 and x [ 23 ] == 0 : status . next = status else : status . next = not status E ent\u00e3o atribu\u00edmos o valor de status para a sa\u00edda led na parte combinacional do m\u00f3dulo: def comb (): led . next = status Melhorando \u00b6 At\u00e9 agora estamos usando mal os recursos do MyHDL, o componente anterior poderia ser muito mais simples se: Pud\u00e9ssemos tratar sinais como inteiros N\u00e3o precis\u00e1ssemos usar o adder Para isso o MyHDL possui outros dois tipos de dados al\u00e9m do bool , vamos trabalhar com o intbv Hardware design involves dealing with bits and bit-oriented operations. The standard Python type int has most of the desired features, but lacks support for indexing and slicing. For this reason, MyHDL provides the intbv class. The name was chosen to suggest an integer with bit vector flavor. Do mamual: http://docs.myhdl.org/en/stable/manual/hwtypes.html Alguns exemplos de como trabalhar com o tipo: >>> a = intbv ( 24 ) >>> b = intbv ( 2 ) >>> print ( a ) 24 >>> print ( a + b ) 26 >>> print ( a == 12 ) False O intbv n\u00e3o limita a quantidade de bits que ser\u00e1 utilizado , isso funciona muito bem na simula\u00e7\u00e3o, mas quando formos gerar um hardware temos que definir o tamanho do vetor caso contr\u00e1rio teremos erro na convers\u00e3o. O exemplo a seguir indica como criarmos um sinal cnt com 32 bits: # cnt com 32 bits do tipo intbv >>> cnt = Signal ( intbv ( 0 )[ 32 :]) >>> cnt . max 4294967296 >>> cnt . min 0 blink melhorado \u00b6 Vamos agora reimplementar o blink, mas usando os novos recursos: @block def blinkLed ( led , clk , rst ): cnt = Signal ( intbv ( 0 )[ 32 :]) l = Signal ( bool ( 0 )) @always_seq ( clk . posedge , reset = rst ) def seq (): if cnt < 25000000 : cnt . next = cnt + 1 else : cnt . next = 0 l . next = not l @always_comb def comb (): led . next = l return instances () Muito mais simples em! =) Exercise File: toplevel.py Tarefa: Modifique o toplevel para usar o novo componente e verifique na placa que ele funciona como deveria. ic1 = blinkLed ( ledr_s [ 0 ], CLOCK_50 , RESET_N ) Exercise O cnt de 32 bits est\u00e1 bem dimensionado? Esse valor faz alguma diferen\u00e7a? cnt = Signal(intbv(0)[32:]) Answer 32 bits = 4294967296 4294967296/50M = 85s Faz diferen\u00e7a sim! Quando mais bits, mais registradores temos que usar e maior ficar o hardware. Poder\u00edamos dimensionar o tamanho do vetor de acordo com o time_ms que foi passado para o m\u00f3dulo. Exercise File: seq_modules.py Fun\u00e7\u00e3o: blinkLed Vamos deixar o componente mais gen\u00e9rico? Para isso modifique a fun\u00e7\u00e3o blinkLed para receber mais um argumento: O valor em ms na qual o LED ir\u00e1 piscar: def blinkLed ( led , time_ms , clk , rst ): Depois modifique o toplevel para validar diferentes valores em diferentes leds: ic1 = blinkLed ( ledr_s [ 0 ], 100 , CLOCK_50 , RESET_N ) ic2 = blinkLed ( ledr_s [ 1 ], 50 , CLOCK_50 , RESET_N ) ic3 = blinkLed ( ledr_s [ 2 ], 1000 , CLOCK_50 , RESET_N ) Lembre de validar na FPGA! Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed Tarefa: Vamos praticar mais! Agora fa\u00e7a com que os LEDs da FPGA acendam em sequ\u00eancia: Primeiro o LED0, depois o LED1... (como uma anima\u00e7\u00e3o), ao chegar no final apague tudo e comece novamente. Dica: Voc\u00ea vai precisar de mais um contador indo de 0 a 9 Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed Modifique a barLed adicionando: SW[0] controla a velocidade dos LEDs: R\u00e1pido ou Lento SW[1] controla a dire\u00e7\u00e3o (esquerda/ direita) def barLed ( leds , time_ms , dir , vel , clk , rst ): Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed2 Tarefa: O barLed2 \u00e9 similar ao LED por\u00e9m s\u00f3 um LED aceso por vez! Dica: Aplique um shift de cntLed ao valor em bin\u00e1rio 000000001 , onde cntLed \u00e9 o contador de 0, 9. @always_comb def comb (): leds . next = intbv ( 1 )[ 10 :] << cntLed Desafio \u00b6 Ideias de LABs com utilidade: Ultrasom HC-SR04? LED RGB StepMotor Servo ...","title":"Lab 8: L\u00f3gica Sequencial"},{"location":"class/seq-lab-1/#lab-8-logica-sequencial","text":"Agora vamos ver como implementamos uma l\u00f3gica sequencia em MyHDL! At\u00e9 agora temos utilizado o decorator : @always_comb para indicar que uma fun\u00e7\u00e3o deve ser interpretada como um trecho combinacional: @always_comb def comb (): led . next = l Agora vamos come\u00e7ar usar um novo decorator ( @always_seq ) para indicar que uma fun\u00e7\u00e3o deve ser sequencial e depender do clock e do reset . O m\u00f3dulo aseguir demonstra como implementar um flip-flop tipo D em MyHDL: @block def dff ( q , d , clk , rst ): @always_seq ( clk . posedge , reset = rst ) def seq (): q . next = d return instances () Notem que estamos usando @always_seq(clk.posedge, reset=rst) , e indicando que o m\u00f3dulo deve ser acionado na borda de subida do sinal clk e que o sinal de reset deve ser o rst . Podemos interpretar o def seq() da seguinte maneira: Sempre que o sinal clock variar de 0 para 1 a fun\u00e7\u00e3o \u00e9 acionada e ent\u00e3o a sa\u00edda q recebe a entrada d . Podemos visualizar isso como um while True: while True : q . next = d time . sleep ( 1 / CLOCK )","title":"Lab 8: L\u00f3gica Sequencial"},{"location":"class/seq-lab-1/#dff","text":"Exercise File: seq/seq_modules.py Tarefa: Vamos validar o flip-flop, para isso modifique o toplevel.py : ic0 = dff ( ledr_s [ 0 ], sw_s [ 0 ], key_s [ 0 ], RESET_N ) E fa\u00e7a o processo completo para obtermos o hardware. Validando: Mapeamos o clock para o KEY[0] e a entrada do dff para o SW[0] , notem que ao mexer a chave SW[0] nada acontece, o valor do LED muda apenas ap\u00f3s apertar o KEY[0] (que \u00e9 o clock )","title":"dff"},{"location":"class/seq-lab-1/#clock","text":"O sinal de clock da nossa FPGA \u00e9 de 50Mhz , ou seja: 50 000 000 vezes por segundo! Isso parece muito n\u00e9? Mas, dependendo do projeto, podemos elevar o clock para 200Mhz ou usar FPGAs mais r\u00e1pidas que chegam pr\u00f3ximo do 1GHz.","title":"Clock"},{"location":"class/seq-lab-1/#piscando-led","text":"Agora com o uso da l\u00f3gica sequencial conseguimos contar 'tempo' e gerar eventos em determinado momento. Ou seja: podemos contar 0.5 segundos e mudar o valor do led, contar mais 0.5 s e mudar novamente (fazer o famoso pisca led ). Para isso, teremos que conseguir contar eventos de clock, e quando o valor chegar em 25 000 000 inverter o valor do LED e zerar o contador e ficar nesse loop para sempre. Podemos usar o nosso adder do lab anterior como m\u00f3dulo de contador, conectando a sa\u00edda do adder na entrada x , mas passando por um registrador antes (para apenas mudar a cada clock). A entrada y ser\u00e1 conectado ao valor 1 , como resultado teremos: s = x + 1 . A express\u00e3o ser\u00e1 executada a cada subida do clock. E x ser\u00e1: if s < MAX : x . next = s else : x . next = 0 Se o valor de s for menor que o valor m\u00e1ximo (define a velocidade que o LED ir\u00e1 piscar) copiamos a sa\u00edda do somador para a entrada, e se o valor MAX for atingido, iremos zerar o somador, para come\u00e7armos novamente. O HW que queremos gerar \u00e9 algo como: A implementa\u00e7\u00e3o em MyHDL: @block def blinkLedAdder ( led , clk , rst ): x = [ Signal ( bool ( 0 )) for i in range ( 32 )] y = [ Signal ( bool ( 0 )) for i in range ( 32 )] s = [ Signal ( bool ( 0 )) for i in range ( 32 )] c = Signal ( bool ( 0 )) status = Signal ( bool ( 0 )) y [ 0 ] = 1 adder_1 = adder ( x , y , s , c ) @always_seq ( clk . posedge , reset = rst ) def seq (): if x [ 21 ] == 0 : for i in range ( len ( x )): x [ i ] . next = s [ i ] status . next = status else : for i in range ( len ( x )): x [ i ] . next = 0 status . next = not status @always_comb def comb (): led . next = status return instances () Exercise File: toplevel.py Modifiquem o toplevel para conter o componente: ic1 = blinkLedAdder ( ledr_s [ 0 ], CLOCK_50 , RESET_N ) E fa\u00e7am o fluxo de rodar o m\u00f3dulo na FPGA. Verifiquem que o LED pisca!! Alguns detalhes devem ser levados em considera\u00e7\u00e3o na implementa\u00e7\u00e3o do componente: Estamos lidando com vetores de bit, que devem ser acessados individualmente O seq acontece a cada mudan\u00e7a do clock O comb acontece sempre N\u00e3o podemos ler uma sa\u00edda - if s < MAX: + if x[24] == 0 and x[23] == 0: Temos que lembrar que estamos lidando com um vetor de bits que n\u00e3o possuem liga\u00e7\u00e3o entre si, ent\u00e3o n\u00e3o podemos fazer uma compara\u00e7\u00e3o como se eles fossem um inteiro: if x < 25000000 , mas temos que verificar os bits individualmente. Nesse caso eu estou verificando se os bits 24 e 23 s\u00e3o iguais a zero. Pois: 2^24 + 2^23 = 25165824 Um valor muito pr\u00f3ximo de 25M (um erro menor que 1%). Que para o pisca led n\u00e3o ser\u00e1 percept\u00edvel. Poder\u00edamos \u00e9 claro melhorar colocando mais bits na verifica\u00e7\u00e3o, mas n\u00e3o \u00e9 necess\u00e1rio. Por conta de x e s serem vetores, temos que fazer uma varredura para atribuirmos cada um dos index: - x.next = s + for i in range(len(x)): + x[i].next = s[i] Warning \u00c9 importante sabermos que o for em hardware n\u00e3o existe, \u00e9 apenas um recurso para facilitar a descri\u00e7\u00e3o do componente, no lugar de escrevermos isso: x[0].next = s[0] x[1].next = s[1] ... A ideia de piscar o LED \u00e9 que temos que mudar uma vari\u00e1vel a cada ciclo do contador. ----------- ------------- | | | Status | | | ----------- ---------- _ 25000000 _ _ / | / | / | / | / | / | Contador / | / | / | / |/ | / | Mas como o sinal led \u00e9 uma sa\u00edda, n\u00e3o podemos acessar ele diretamente. Para isso, eu criei um sinal interno auxiliar status que \u00e9 alterado sempre que o contador \u00e9 zerado: def seq (): if x [ 24 ] == 0 and x [ 23 ] == 0 : status . next = status else : status . next = not status E ent\u00e3o atribu\u00edmos o valor de status para a sa\u00edda led na parte combinacional do m\u00f3dulo: def comb (): led . next = status","title":"Piscando LED"},{"location":"class/seq-lab-1/#melhorando","text":"At\u00e9 agora estamos usando mal os recursos do MyHDL, o componente anterior poderia ser muito mais simples se: Pud\u00e9ssemos tratar sinais como inteiros N\u00e3o precis\u00e1ssemos usar o adder Para isso o MyHDL possui outros dois tipos de dados al\u00e9m do bool , vamos trabalhar com o intbv Hardware design involves dealing with bits and bit-oriented operations. The standard Python type int has most of the desired features, but lacks support for indexing and slicing. For this reason, MyHDL provides the intbv class. The name was chosen to suggest an integer with bit vector flavor. Do mamual: http://docs.myhdl.org/en/stable/manual/hwtypes.html Alguns exemplos de como trabalhar com o tipo: >>> a = intbv ( 24 ) >>> b = intbv ( 2 ) >>> print ( a ) 24 >>> print ( a + b ) 26 >>> print ( a == 12 ) False O intbv n\u00e3o limita a quantidade de bits que ser\u00e1 utilizado , isso funciona muito bem na simula\u00e7\u00e3o, mas quando formos gerar um hardware temos que definir o tamanho do vetor caso contr\u00e1rio teremos erro na convers\u00e3o. O exemplo a seguir indica como criarmos um sinal cnt com 32 bits: # cnt com 32 bits do tipo intbv >>> cnt = Signal ( intbv ( 0 )[ 32 :]) >>> cnt . max 4294967296 >>> cnt . min 0","title":"Melhorando"},{"location":"class/seq-lab-1/#blink-melhorado","text":"Vamos agora reimplementar o blink, mas usando os novos recursos: @block def blinkLed ( led , clk , rst ): cnt = Signal ( intbv ( 0 )[ 32 :]) l = Signal ( bool ( 0 )) @always_seq ( clk . posedge , reset = rst ) def seq (): if cnt < 25000000 : cnt . next = cnt + 1 else : cnt . next = 0 l . next = not l @always_comb def comb (): led . next = l return instances () Muito mais simples em! =) Exercise File: toplevel.py Tarefa: Modifique o toplevel para usar o novo componente e verifique na placa que ele funciona como deveria. ic1 = blinkLed ( ledr_s [ 0 ], CLOCK_50 , RESET_N ) Exercise O cnt de 32 bits est\u00e1 bem dimensionado? Esse valor faz alguma diferen\u00e7a? cnt = Signal(intbv(0)[32:]) Answer 32 bits = 4294967296 4294967296/50M = 85s Faz diferen\u00e7a sim! Quando mais bits, mais registradores temos que usar e maior ficar o hardware. Poder\u00edamos dimensionar o tamanho do vetor de acordo com o time_ms que foi passado para o m\u00f3dulo. Exercise File: seq_modules.py Fun\u00e7\u00e3o: blinkLed Vamos deixar o componente mais gen\u00e9rico? Para isso modifique a fun\u00e7\u00e3o blinkLed para receber mais um argumento: O valor em ms na qual o LED ir\u00e1 piscar: def blinkLed ( led , time_ms , clk , rst ): Depois modifique o toplevel para validar diferentes valores em diferentes leds: ic1 = blinkLed ( ledr_s [ 0 ], 100 , CLOCK_50 , RESET_N ) ic2 = blinkLed ( ledr_s [ 1 ], 50 , CLOCK_50 , RESET_N ) ic3 = blinkLed ( ledr_s [ 2 ], 1000 , CLOCK_50 , RESET_N ) Lembre de validar na FPGA! Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed Tarefa: Vamos praticar mais! Agora fa\u00e7a com que os LEDs da FPGA acendam em sequ\u00eancia: Primeiro o LED0, depois o LED1... (como uma anima\u00e7\u00e3o), ao chegar no final apague tudo e comece novamente. Dica: Voc\u00ea vai precisar de mais um contador indo de 0 a 9 Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed Modifique a barLed adicionando: SW[0] controla a velocidade dos LEDs: R\u00e1pido ou Lento SW[1] controla a dire\u00e7\u00e3o (esquerda/ direita) def barLed ( leds , time_ms , dir , vel , clk , rst ): Exercise File: seq_modules.py Fun\u00e7\u00e3o: barLed2 Tarefa: O barLed2 \u00e9 similar ao LED por\u00e9m s\u00f3 um LED aceso por vez! Dica: Aplique um shift de cntLed ao valor em bin\u00e1rio 000000001 , onde cntLed \u00e9 o contador de 0, 9. @always_comb def comb (): leds . next = intbv ( 1 )[ 10 :] << cntLed","title":"blink melhorado"},{"location":"class/seq-lab-1/#desafio","text":"Ideias de LABs com utilidade: Ultrasom HC-SR04? LED RGB StepMotor Servo ...","title":"Desafio"},{"location":"class/ula-lab-1/","text":"Lab 6: Adders \u00b6 Neste laborat\u00f3rio iremos desenvolver somadores que ser\u00e3o utilizados no desenvolvimento da unidade l\u00f3gica aritm\u00e9tica da nossa CPU. Half e Full adder \u00b6 Vamos comecar implementando as duas unidades b\u00e1sicas s\u00e3o utilizadas em um somador: half-adder e full-adder. Exercise File: ula/ula_modules.py Modulo: def halfAdder(a, b, soma, vaiUm): Test: pytest -k halfAdder Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder Reutilizando componente ( Structural Modeling ) \u00b6 Info Para mais detalhes acesse a documenta\u00e7\u00e3o do MyHDL http://docs.myhdl.org/en/stable/manual/structure.html A modelagem estrutural em hardware pode ser entendida como a utiliza\u00e7\u00e3o de diferentes m\u00f3dulos para construir um novo. Lembre que estamos desenvolvendo um hardware e n\u00e3o criando um software, e que esse hardware deve ser sintetiz\u00e1vel (poss\u00edvel de implementar na FPGA). Para isso devemos criar \"instancias\" de um componente, por exemplo: Podemos criar uma inst\u00e2ncia do halfAdder e outra do fullAdder para implementarmos um somador de dois bits. Podemos pensar nessas inst\u00e2ncias como \"ir at\u00e9 o arm\u00e1rio do laborat\u00f3rio e pegar um CI de cada tipo\", cada inst\u00e2ncia \u00e9 executada em paralelo e consume recursos pr\u00f3prios, quanto mais inst\u00e2ncias, mais complexo \u00e9 o hardware e mais recursos s\u00e3o utilizados. halfAdder \u00b6 Como exemplo do processo vamos reimplementar o fullAdder, mas agora utilizando dois halfAdders, como demonstrado no diagrama a seguir: O c\u00f3digo em python fica: @block def fullAdder ( a , b , c , q , carry ): s0 = Signal ( bool ( 0 )) # (1) s1 = Signal ( bool ( 0 )) s2 = Signal ( bool ( 0 )) half_1 = halfAdder ( a , b , s0 , s1 ) # (2) half_2 = halfAdder ( c , s0 , q , s2 ) # (3) @always_comb def comb (): carry . next = s1 | s2 # (4) return instances () Sinais internos para conex\u00e3o Primeira instancia do half adder Segunda instancia do half adder Implementa\u00e7\u00e3o da porta or entre as sa\u00eddas dos carrys Notem que na implementa\u00e7\u00e3o anterior utilizamos tr\u00eas sinais bin\u00e1rios interno ( s0 , s1 e s2 ) no m\u00f3dulo para a conex\u00e3o entre os componentes e que a l\u00f3gica do OR entre os carrys \u00e9 implementada em um bloco combinacional def comb . Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder Tarefa: Modifique o fullAdder para utilizar dois hallAdders, execute o teste novamente e note que ele passa. Podemos melhorar um pouco o c\u00f3digo anterior se no lugar dos sinais s0 , s1 e s2 cri\u00e1ssemos um vetor de sinais s[] com tr\u00eas itens. - s0 = Signal(bool(0)) - s1 = Signal(bool(0)) - s2 = Signal(bool(0)) + s = [Signal(bool(0)) for i in range(3)] Com isso temos um vetor de bits s que pode ser endere\u00e7ado como s[0] , s[1] e s[2] . Tip O MyHDL possui um tipo pr\u00f3prio para tratar um vetor de bits ( intbv ou modbv ), mas por enquanto vamos usar o vetor criado por v\u00e1rios bools. A diferen\u00e7a entre os dois m\u00e9todos \u00e9 que no intbv os bits s\u00e3o interpretados como um \u00fanico sinal ( unsigned ou signed , como se fosse uma vari\u00e1vel) e no vetor criado por bools os bits s\u00e3o independentes! Exercise Modifique novamenge o fullAdder , mas agora usando um vetor de bits s[] no lugar dos tr\u00eas sinais s0 , s1 e s2 . Solu\u00e7\u00e3o @block def fullAdder ( a , b , c , soma , carry ): s = [ Signal ( bool ( 0 )) for i in range ( 3 )] half_1 = halfAdder ( a , b , s [ 0 ], s [ 1 ]) half_2 = halfAdder ( c , s [ 0 ], soma , s [ 2 ]) @always_comb def comb (): carry . next = s [ 1 ] | s [ 2 ] return instances () Somador \u00b6 Agora com os dois m\u00f3dulos implementados podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de um halfAdder (HA) e um fullAdders (FA) conectados da seguinte maneira: x1 y1 x0 y0 | | /--------\\ | | | | | | | | .-v--v--v--. | .--v--v----. | a b c | | | a b | | | | | | carry <---carry | <---carry | | soma | | soma | .--|-------. .--|-------. | FA | HA v v q1 q0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x[1..0] + y[1..0] que resulta em uma soma de dois bits: q[1..0] e um carry . @block def adder2bits ( x , y , soma , carry ): # adder de 2 bits! Onde x , y e s s\u00e3o vetores do tipo bool de duas posi\u00e7\u00f5es. Exercise Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o e como ela funciona? Exercise Modulo: def adder2bits(x, y, soma, vaiUm): Test: pytest -k adder2bits Run: ./run_adder2bits.py Tarefa: Modifique o adder2bits para implementar um somador de dois bits como demonstrado no diagrama anterior. Teste com pytest Voc\u00ea pode testar o m\u00f3dulo executando ele: ./run_adder2bits . Voc\u00ea deve dar como entrada os valores de x e y em decimal. Lembre que para dois bits o valor m\u00e1ximo \u00e9 3 . Generalizando \u00b6 O somador que criamos funciona apenas para vetores de dois bits, mas somos capazes de criar um m\u00f3dulo gen\u00e9rico que realiza a opera\u00e7\u00e3o em N bits (N o tamanho dos vetores de entrada). Para isso deveremos usar um for que ir\u00e1 criar N inst\u00e2ncias do FA para atender a necessidade do tamanho das entradas. Para isso ser\u00e1 necess\u00e1rio criar uma lista de componentes, que ser\u00e1 gerada com base no tamanho do vetor da soma. Vamos analisar como fazer isso com o exemplo do FA que utiliza dois halfAdders, para isso iremos criar uma lista do tipo None e ent\u00e3o inicializar cada elementos dela com um halfAdder: haList = [ None for i in range ( 2 )] # (1) Implementa\u00e7\u00e3o fullAdder com lista de componentes fica assim: @block def fullAdder ( a , b , c , soma , carry ): s = [ Signal ( bool ( 0 )) for i in range ( 3 )] haList = [ None for i in range ( 2 )] # (1) haList [ 0 ] = halfAdder ( a , b , s [ 0 ], s [ 1 ]) haList [ 1 ] = halfAdder ( c , s [ 0 ], soma , s [ 2 ]) @always_comb def comb (): carry . next = s [ 1 ] | s [ 2 ] return instances () Lista de dois componentes n\u00e3o inicializada Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder Tarefa: Modifique o fullAdder para usar uma lista de componentes. Agora que sabemos como podemos criar uma lista de componentes, podemos fazer a implementa\u00e7\u00e3o do adder que se adapta a quantidade de bits que ele recebe. Isso \u00e9 interessante pois podemos usar o mesmo adder instanciado de diferentes maneiras como um hardware dedicado para somar vetores de 2 bits, 8 ou quanto quisermos. Vamos ver mais para frente que a largura do somador \u00e9 determinada pela arquitetura da CPU, j\u00e1 reparou que alguns programas quando voc\u00ea vai baixar possuem a op\u00e7\u00e3o x64 ou x86 ? Isso determina entre outras coisas, qual a largura de dados da CPU em quest\u00e3o, 64 ou 32 bits. Exercise Modulo: def adder(x, y, soma, vaiUm): Test: pytest -k adder Run: ./run_adder.py Tarefa: Implemente o m\u00f3dulo adder que \u00e9 um somador gen\u00e9rico. Teste com pytest test_adder Dicas: Para saber o tamanho do vetor use n = len(x) Crie uma lista de componente de tamanho faList = [None for i in range(n)] Utilize caneta e papel, desenhe um m\u00f3dulo somador de tamanho 3 e tente depois generalizar. Tente apenas usar fullAdder na implementa\u00e7\u00e3o Fa\u00e7a um loop para inicializar cada um dos componentes for i in range ( n ): faList [ n ] = fullAdder ( x [ i ], ... ) FPGA \u00b6 Agora vamos executar o adder na FPGA! Vamos usar a implementa\u00e7\u00e3o do adder gen\u00e9rico com 4 bits para o vetor x e 4 bits para o y , vamos mapear os bits para as chaves da FPGA e a sa\u00edda do adder para os LEDs, o carry vai ser o \u00faltimo LED. No toplevel.py eu estou usando o bin2hex do laborat\u00f3rio anterior para mostrar no display HEX0 o resultado da soma. Exercise Modifique o toplevel.py : ic1 = adder ( sw [ 0 : 4 ], sw [ 6 : 10 ], ledr_s [ 0 : 4 ], ledr_s [ 9 ]) ic2 = bin2hex ( HEX0 , ledr_bin ) Gerar o toplevel.vhd rodando toplevel.py Compile o vhdl make -C quartus clean make -C quartus all . make -C quartus program Validar na FPGA","title":"Lab 6: Adders"},{"location":"class/ula-lab-1/#lab-6-adders","text":"Neste laborat\u00f3rio iremos desenvolver somadores que ser\u00e3o utilizados no desenvolvimento da unidade l\u00f3gica aritm\u00e9tica da nossa CPU.","title":"Lab 6: Adders"},{"location":"class/ula-lab-1/#half-e-full-adder","text":"Vamos comecar implementando as duas unidades b\u00e1sicas s\u00e3o utilizadas em um somador: half-adder e full-adder. Exercise File: ula/ula_modules.py Modulo: def halfAdder(a, b, soma, vaiUm): Test: pytest -k halfAdder Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder","title":"Half e Full adder"},{"location":"class/ula-lab-1/#reutilizando-componente-structural-modeling","text":"Info Para mais detalhes acesse a documenta\u00e7\u00e3o do MyHDL http://docs.myhdl.org/en/stable/manual/structure.html A modelagem estrutural em hardware pode ser entendida como a utiliza\u00e7\u00e3o de diferentes m\u00f3dulos para construir um novo. Lembre que estamos desenvolvendo um hardware e n\u00e3o criando um software, e que esse hardware deve ser sintetiz\u00e1vel (poss\u00edvel de implementar na FPGA). Para isso devemos criar \"instancias\" de um componente, por exemplo: Podemos criar uma inst\u00e2ncia do halfAdder e outra do fullAdder para implementarmos um somador de dois bits. Podemos pensar nessas inst\u00e2ncias como \"ir at\u00e9 o arm\u00e1rio do laborat\u00f3rio e pegar um CI de cada tipo\", cada inst\u00e2ncia \u00e9 executada em paralelo e consume recursos pr\u00f3prios, quanto mais inst\u00e2ncias, mais complexo \u00e9 o hardware e mais recursos s\u00e3o utilizados.","title":"Reutilizando componente ( Structural Modeling )"},{"location":"class/ula-lab-1/#halfadder","text":"Como exemplo do processo vamos reimplementar o fullAdder, mas agora utilizando dois halfAdders, como demonstrado no diagrama a seguir: O c\u00f3digo em python fica: @block def fullAdder ( a , b , c , q , carry ): s0 = Signal ( bool ( 0 )) # (1) s1 = Signal ( bool ( 0 )) s2 = Signal ( bool ( 0 )) half_1 = halfAdder ( a , b , s0 , s1 ) # (2) half_2 = halfAdder ( c , s0 , q , s2 ) # (3) @always_comb def comb (): carry . next = s1 | s2 # (4) return instances () Sinais internos para conex\u00e3o Primeira instancia do half adder Segunda instancia do half adder Implementa\u00e7\u00e3o da porta or entre as sa\u00eddas dos carrys Notem que na implementa\u00e7\u00e3o anterior utilizamos tr\u00eas sinais bin\u00e1rios interno ( s0 , s1 e s2 ) no m\u00f3dulo para a conex\u00e3o entre os componentes e que a l\u00f3gica do OR entre os carrys \u00e9 implementada em um bloco combinacional def comb . Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder Tarefa: Modifique o fullAdder para utilizar dois hallAdders, execute o teste novamente e note que ele passa. Podemos melhorar um pouco o c\u00f3digo anterior se no lugar dos sinais s0 , s1 e s2 cri\u00e1ssemos um vetor de sinais s[] com tr\u00eas itens. - s0 = Signal(bool(0)) - s1 = Signal(bool(0)) - s2 = Signal(bool(0)) + s = [Signal(bool(0)) for i in range(3)] Com isso temos um vetor de bits s que pode ser endere\u00e7ado como s[0] , s[1] e s[2] . Tip O MyHDL possui um tipo pr\u00f3prio para tratar um vetor de bits ( intbv ou modbv ), mas por enquanto vamos usar o vetor criado por v\u00e1rios bools. A diferen\u00e7a entre os dois m\u00e9todos \u00e9 que no intbv os bits s\u00e3o interpretados como um \u00fanico sinal ( unsigned ou signed , como se fosse uma vari\u00e1vel) e no vetor criado por bools os bits s\u00e3o independentes! Exercise Modifique novamenge o fullAdder , mas agora usando um vetor de bits s[] no lugar dos tr\u00eas sinais s0 , s1 e s2 . Solu\u00e7\u00e3o @block def fullAdder ( a , b , c , soma , carry ): s = [ Signal ( bool ( 0 )) for i in range ( 3 )] half_1 = halfAdder ( a , b , s [ 0 ], s [ 1 ]) half_2 = halfAdder ( c , s [ 0 ], soma , s [ 2 ]) @always_comb def comb (): carry . next = s [ 1 ] | s [ 2 ] return instances ()","title":"halfAdder"},{"location":"class/ula-lab-1/#somador","text":"Agora com os dois m\u00f3dulos implementados podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de um halfAdder (HA) e um fullAdders (FA) conectados da seguinte maneira: x1 y1 x0 y0 | | /--------\\ | | | | | | | | .-v--v--v--. | .--v--v----. | a b c | | | a b | | | | | | carry <---carry | <---carry | | soma | | soma | .--|-------. .--|-------. | FA | HA v v q1 q0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x[1..0] + y[1..0] que resulta em uma soma de dois bits: q[1..0] e um carry . @block def adder2bits ( x , y , soma , carry ): # adder de 2 bits! Onde x , y e s s\u00e3o vetores do tipo bool de duas posi\u00e7\u00f5es. Exercise Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o e como ela funciona? Exercise Modulo: def adder2bits(x, y, soma, vaiUm): Test: pytest -k adder2bits Run: ./run_adder2bits.py Tarefa: Modifique o adder2bits para implementar um somador de dois bits como demonstrado no diagrama anterior. Teste com pytest Voc\u00ea pode testar o m\u00f3dulo executando ele: ./run_adder2bits . Voc\u00ea deve dar como entrada os valores de x e y em decimal. Lembre que para dois bits o valor m\u00e1ximo \u00e9 3 .","title":"Somador"},{"location":"class/ula-lab-1/#generalizando","text":"O somador que criamos funciona apenas para vetores de dois bits, mas somos capazes de criar um m\u00f3dulo gen\u00e9rico que realiza a opera\u00e7\u00e3o em N bits (N o tamanho dos vetores de entrada). Para isso deveremos usar um for que ir\u00e1 criar N inst\u00e2ncias do FA para atender a necessidade do tamanho das entradas. Para isso ser\u00e1 necess\u00e1rio criar uma lista de componentes, que ser\u00e1 gerada com base no tamanho do vetor da soma. Vamos analisar como fazer isso com o exemplo do FA que utiliza dois halfAdders, para isso iremos criar uma lista do tipo None e ent\u00e3o inicializar cada elementos dela com um halfAdder: haList = [ None for i in range ( 2 )] # (1) Implementa\u00e7\u00e3o fullAdder com lista de componentes fica assim: @block def fullAdder ( a , b , c , soma , carry ): s = [ Signal ( bool ( 0 )) for i in range ( 3 )] haList = [ None for i in range ( 2 )] # (1) haList [ 0 ] = halfAdder ( a , b , s [ 0 ], s [ 1 ]) haList [ 1 ] = halfAdder ( c , s [ 0 ], soma , s [ 2 ]) @always_comb def comb (): carry . next = s [ 1 ] | s [ 2 ] return instances () Lista de dois componentes n\u00e3o inicializada Exercise Modulo: def fullAdder(a, b, soma, vaiUm): Test: pytest -k fullAdder Tarefa: Modifique o fullAdder para usar uma lista de componentes. Agora que sabemos como podemos criar uma lista de componentes, podemos fazer a implementa\u00e7\u00e3o do adder que se adapta a quantidade de bits que ele recebe. Isso \u00e9 interessante pois podemos usar o mesmo adder instanciado de diferentes maneiras como um hardware dedicado para somar vetores de 2 bits, 8 ou quanto quisermos. Vamos ver mais para frente que a largura do somador \u00e9 determinada pela arquitetura da CPU, j\u00e1 reparou que alguns programas quando voc\u00ea vai baixar possuem a op\u00e7\u00e3o x64 ou x86 ? Isso determina entre outras coisas, qual a largura de dados da CPU em quest\u00e3o, 64 ou 32 bits. Exercise Modulo: def adder(x, y, soma, vaiUm): Test: pytest -k adder Run: ./run_adder.py Tarefa: Implemente o m\u00f3dulo adder que \u00e9 um somador gen\u00e9rico. Teste com pytest test_adder Dicas: Para saber o tamanho do vetor use n = len(x) Crie uma lista de componente de tamanho faList = [None for i in range(n)] Utilize caneta e papel, desenhe um m\u00f3dulo somador de tamanho 3 e tente depois generalizar. Tente apenas usar fullAdder na implementa\u00e7\u00e3o Fa\u00e7a um loop para inicializar cada um dos componentes for i in range ( n ): faList [ n ] = fullAdder ( x [ i ], ... )","title":"Generalizando"},{"location":"class/ula-lab-1/#fpga","text":"Agora vamos executar o adder na FPGA! Vamos usar a implementa\u00e7\u00e3o do adder gen\u00e9rico com 4 bits para o vetor x e 4 bits para o y , vamos mapear os bits para as chaves da FPGA e a sa\u00edda do adder para os LEDs, o carry vai ser o \u00faltimo LED. No toplevel.py eu estou usando o bin2hex do laborat\u00f3rio anterior para mostrar no display HEX0 o resultado da soma. Exercise Modifique o toplevel.py : ic1 = adder ( sw [ 0 : 4 ], sw [ 6 : 10 ], ledr_s [ 0 : 4 ], ledr_s [ 9 ]) ic2 = bin2hex ( HEX0 , ledr_bin ) Gerar o toplevel.vhd rodando toplevel.py Compile o vhdl make -C quartus clean make -C quartus all . make -C quartus program Validar na FPGA","title":"FPGA"},{"location":"class/ula-lab-2/","text":"Lab 7: Depurando \u00b6 Depurar hardaware (debugar) n\u00e3o \u00e9 uma taref\u00e1 f\u00e1cil, o problema pode estar em v\u00e1rios lugares diferentes: Componente queimando, solda com mal contato, erros no projeto de hardware, erro no software, clock com jiter ..... A lista de onde um problema pode estar \u00e9 enorme e envolve v\u00e1rias \u00e1reas. Aqui na disciplina vamos assumir uma lista menor de problemas, pois iremos eliminar que a placa pode estar com defeito (ou que n\u00e3o foi bem projetada) e que haja algum defeito na configura\u00e7\u00e3o do Quartus. Basicamente os problemas podem ser: No entendimento da logica Na transcri\u00e7\u00e3o de uma l\u00f3gica combinacional/ sequencial para RTL (portas l\u00f3gicas) No uso de recursos do MyHDL Com o MyHDL conseguimos depurar um m\u00f3dulo de diversas maneiras e em diferentes camadas. Como estamos no ambiente do python, conseguimos inserir prints ou usar breakpoints() e acompanhar a simula\u00e7\u00e3o passo a passo . Podemos tamb\u00e9m gerar um diagrama de forma de ondas, que \u00e9 muito utilizado para a depura\u00e7\u00e3o de hardware. Para entendermos o processo iremos usar como exemplo o m\u00f3dulo fullAdder que est\u00e1 em uso pelo adder2bits do lab anterior. print \u00b6 Podemos inserir prints nos componentes a fim de ajudar no desenvolvimento do mesmo. Temos que entender que o print n\u00e3o \u00e9 sintetiz\u00e1vel (n\u00e3o vai para a FPGA) e est\u00e1 limitado a apenas inputs e sinais internos do m\u00f3dulo, n\u00e3o podemos usar o print em outputs . Por exemplo, se desejarmos exibir o valor da sa\u00edda soma do halfAdder , poder\u00edamos inserir um print, mas como soma \u00e9 uma sa\u00edda , vamos ter um erro: ula_modules.py @block def halfAdder ( a , b , soma , carry ): @always_comb def comb (): soma . next = a ^ b carry . next = a & b print ( soma ) # (1) return instances () print no soma que \u00e9 uma sa\u00edda, n\u00e3o podemos fazer isso! myhdl.AlwaysCombError: signal ({'soma'}) used as inout in always_comb function argument Para solucionar esse problema podemos criar um sinal interno auxiliar (que ser\u00e1 vis\u00edvel como entrada e sa\u00edda): ula_modules.py @block def halfAdder ( a , b , soma , carry ): s_soma = Signal ( bool ()) @always_comb def comb (): s_soma = a ^ b soma . next = s_soma carry . next = a & b print ( s_soma ) return instances () Info Notem que nesse caso n\u00e3o usamos s_soma.next = a ^ b , se fizermos Agora se executarmos o teste com pytest -k halfAdder -s , -s ativa o print para o terminal , iremos obter o resultado da soma a cada intera\u00e7\u00e3o do teste: False True True False Exercise File: 2-ula/ula_modules.py Modulo: def halfAdder(a, b, soma, vaiUm): Test: pytest -k halfAdder -s Modifique o m\u00f3dulo para obter um print que exibe as entradas a , b e as sa\u00eddas soma e carry , como: a: 0 b: 0 | s: 0 c: 0 a: 0 b: 1 | s: 1 c: 0 a: 1 b: 0 | s: 1 c: 0 a: 1 b: 1 | s: 0 c: 1 Dica: utilize bin(a) para formatar a sa\u00edda como bin\u00e1rio. breakpoint \u00b6 Uma outra op\u00e7\u00e3o muito poderosa que possu\u00edmos \u00e9 de utilizarmos breakpoint no c\u00f3digo, para isso basta adicionar breakpoint() onde voc\u00ea deseja interromper a execu\u00e7\u00e3o do c\u00f3digo,e ent\u00e3o executar novamente o teste. @block def halfAdder(a, b, soma, carry): s = Signal(bool()) c = Signal(bool()) @always_comb def comb(): breakpoint() s = a ^ b c = a & b soma.next = s carry.next = c print(\"a: %s b: %s | s: %s c: %s\" % (bin(a), bin(b), bin(s), bin(c))) return instances() Quando o programar atingir a linha do breakpoint. Nesse momento podemos usar uma s\u00e9rie de recursos, vamos ver os mais importantes: print(a) : Voc\u00ea pode imprimir o valor de qualquer vari\u00e1vel ou opera\u00e7\u00e3o n : (next) Podemos executar linha a linha o programa c : (continue) Podemos liberar a execu\u00e7\u00e3o do programa at\u00e9 ele encontrar um novo breakpoint ou finalizar w (where) Exibi informa\u00e7\u00f5es do local do breakpoint Exercise Insira o breakpoint() na linha indicada no exemplo anterior e pratique um pouco Exercise Remova o breakpoint() Lembrem de sempre remover o breakpoint ap\u00f3s o uso. wave \u00b6 Como as coisas em hardware acontecem simultaneamente fica dif\u00edcil visualizar o que est\u00e1 acontecendo em todo o projeto, como alternativa podemos gerar uma forma de onda do hardware e visualizar o que est\u00e1 acontecendo com os sinais. Note que na pasta 2-ula foi gerado um arquivo chamado de adder2bits.vcd , esse arquivo possui a forma de onda do teste. Para visualizarmos iremos usar o programa gtkwave . No terminal, execute: Terminal gtkwave adder2bits.vcd Todo Adicionar v\u00eddeo de como usar o gtkwave","title":"Lab 7: Depurando"},{"location":"class/ula-lab-2/#lab-7-depurando","text":"Depurar hardaware (debugar) n\u00e3o \u00e9 uma taref\u00e1 f\u00e1cil, o problema pode estar em v\u00e1rios lugares diferentes: Componente queimando, solda com mal contato, erros no projeto de hardware, erro no software, clock com jiter ..... A lista de onde um problema pode estar \u00e9 enorme e envolve v\u00e1rias \u00e1reas. Aqui na disciplina vamos assumir uma lista menor de problemas, pois iremos eliminar que a placa pode estar com defeito (ou que n\u00e3o foi bem projetada) e que haja algum defeito na configura\u00e7\u00e3o do Quartus. Basicamente os problemas podem ser: No entendimento da logica Na transcri\u00e7\u00e3o de uma l\u00f3gica combinacional/ sequencial para RTL (portas l\u00f3gicas) No uso de recursos do MyHDL Com o MyHDL conseguimos depurar um m\u00f3dulo de diversas maneiras e em diferentes camadas. Como estamos no ambiente do python, conseguimos inserir prints ou usar breakpoints() e acompanhar a simula\u00e7\u00e3o passo a passo . Podemos tamb\u00e9m gerar um diagrama de forma de ondas, que \u00e9 muito utilizado para a depura\u00e7\u00e3o de hardware. Para entendermos o processo iremos usar como exemplo o m\u00f3dulo fullAdder que est\u00e1 em uso pelo adder2bits do lab anterior.","title":"Lab 7: Depurando"},{"location":"class/ula-lab-2/#print","text":"Podemos inserir prints nos componentes a fim de ajudar no desenvolvimento do mesmo. Temos que entender que o print n\u00e3o \u00e9 sintetiz\u00e1vel (n\u00e3o vai para a FPGA) e est\u00e1 limitado a apenas inputs e sinais internos do m\u00f3dulo, n\u00e3o podemos usar o print em outputs . Por exemplo, se desejarmos exibir o valor da sa\u00edda soma do halfAdder , poder\u00edamos inserir um print, mas como soma \u00e9 uma sa\u00edda , vamos ter um erro: ula_modules.py @block def halfAdder ( a , b , soma , carry ): @always_comb def comb (): soma . next = a ^ b carry . next = a & b print ( soma ) # (1) return instances () print no soma que \u00e9 uma sa\u00edda, n\u00e3o podemos fazer isso! myhdl.AlwaysCombError: signal ({'soma'}) used as inout in always_comb function argument Para solucionar esse problema podemos criar um sinal interno auxiliar (que ser\u00e1 vis\u00edvel como entrada e sa\u00edda): ula_modules.py @block def halfAdder ( a , b , soma , carry ): s_soma = Signal ( bool ()) @always_comb def comb (): s_soma = a ^ b soma . next = s_soma carry . next = a & b print ( s_soma ) return instances () Info Notem que nesse caso n\u00e3o usamos s_soma.next = a ^ b , se fizermos Agora se executarmos o teste com pytest -k halfAdder -s , -s ativa o print para o terminal , iremos obter o resultado da soma a cada intera\u00e7\u00e3o do teste: False True True False Exercise File: 2-ula/ula_modules.py Modulo: def halfAdder(a, b, soma, vaiUm): Test: pytest -k halfAdder -s Modifique o m\u00f3dulo para obter um print que exibe as entradas a , b e as sa\u00eddas soma e carry , como: a: 0 b: 0 | s: 0 c: 0 a: 0 b: 1 | s: 1 c: 0 a: 1 b: 0 | s: 1 c: 0 a: 1 b: 1 | s: 0 c: 1 Dica: utilize bin(a) para formatar a sa\u00edda como bin\u00e1rio.","title":"print"},{"location":"class/ula-lab-2/#breakpoint","text":"Uma outra op\u00e7\u00e3o muito poderosa que possu\u00edmos \u00e9 de utilizarmos breakpoint no c\u00f3digo, para isso basta adicionar breakpoint() onde voc\u00ea deseja interromper a execu\u00e7\u00e3o do c\u00f3digo,e ent\u00e3o executar novamente o teste. @block def halfAdder(a, b, soma, carry): s = Signal(bool()) c = Signal(bool()) @always_comb def comb(): breakpoint() s = a ^ b c = a & b soma.next = s carry.next = c print(\"a: %s b: %s | s: %s c: %s\" % (bin(a), bin(b), bin(s), bin(c))) return instances() Quando o programar atingir a linha do breakpoint. Nesse momento podemos usar uma s\u00e9rie de recursos, vamos ver os mais importantes: print(a) : Voc\u00ea pode imprimir o valor de qualquer vari\u00e1vel ou opera\u00e7\u00e3o n : (next) Podemos executar linha a linha o programa c : (continue) Podemos liberar a execu\u00e7\u00e3o do programa at\u00e9 ele encontrar um novo breakpoint ou finalizar w (where) Exibi informa\u00e7\u00f5es do local do breakpoint Exercise Insira o breakpoint() na linha indicada no exemplo anterior e pratique um pouco Exercise Remova o breakpoint() Lembrem de sempre remover o breakpoint ap\u00f3s o uso.","title":"breakpoint"},{"location":"class/ula-lab-2/#wave","text":"Como as coisas em hardware acontecem simultaneamente fica dif\u00edcil visualizar o que est\u00e1 acontecendo em todo o projeto, como alternativa podemos gerar uma forma de onda do hardware e visualizar o que est\u00e1 acontecendo com os sinais. Note que na pasta 2-ula foi gerado um arquivo chamado de adder2bits.vcd , esse arquivo possui a forma de onda do teste. Para visualizarmos iremos usar o programa gtkwave . No terminal, execute: Terminal gtkwave adder2bits.vcd Todo Adicionar v\u00eddeo de como usar o gtkwave","title":"wave"},{"location":"commum-content/exercicios/Exercicio-Algebra-Booleana-1/","text":"\u00c1lgebra Booleana - 1 \u00b6 Resolu\u00e7\u00e3o Exercise Indique o nome dos elementos l\u00f3gicos a seguir: Answer and, nand, or, nor, xor, not Tabela verdade \u00b6 Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 Answer xor Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 Answer nand Pergunta Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Answer \\(A B + A\\bar{C} + A . D\\) Pergunta Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obtem: \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Answer \\(\\bar{A}+\\bar{B}+\\bar{C}\\) Pergunta Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Answer \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) e \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) Pergunta Qual forma can\u00f4nica est\u00e1 correta? A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Answer \\(Q = \\bar{A} . \\bar{B} + A . B\\) Exercise Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. SoP: Soma dos Produtos / PoS: Produto das Somas Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os s\u00edmbolos da \u00e1lgebra booleana. Exercise Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Answer 4 Exercise Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: Answer \\(G = (A+B) C D E\\) Exercise Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A \\, and \\, B) \\, or \\, C\\) Exercise Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Exercise Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \\(Z = \\bar{A} + B + \\bar{C} + D\\) Answer \"1010\" Pergunta Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \\(A . (\\bar{A} + B)= A . B\\) \\(A + (\\bar{A} . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Answer \\(A + (\\bar{A} . B) = A\\) Exercise Simplifique a seguinte express\u00e3o: \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Answer \\(\\bar{C} + \\bar{A} B C\\) Exercise Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: Exercise Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Exercise Crie o mapa de Karnaugh da tabela verdade de quatro entradas. A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Exercise Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) Exercise A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize-a. \\((A+B+C)(A+B+\\bar{C})(A+\\bar{B}+C)(\\bar{A}+B+C)(\\bar{A}+\\bar{B}+C)\\) dica: Equa\u00e7\u00e3o -> tabela verdade -> soma dos produtos Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Algebra-Booleana-1/#algebra-booleana-1","text":"Resolu\u00e7\u00e3o Exercise Indique o nome dos elementos l\u00f3gicos a seguir: Answer and, nand, or, nor, xor, not","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Algebra-Booleana-1/#tabela-verdade","text":"Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 Answer xor Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 Answer nand Pergunta Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Answer \\(A B + A\\bar{C} + A . D\\) Pergunta Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obtem: \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Answer \\(\\bar{A}+\\bar{B}+\\bar{C}\\) Pergunta Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Answer \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) e \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) Pergunta Qual forma can\u00f4nica est\u00e1 correta? A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Answer \\(Q = \\bar{A} . \\bar{B} + A . B\\) Exercise Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. SoP: Soma dos Produtos / PoS: Produto das Somas Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os s\u00edmbolos da \u00e1lgebra booleana. Exercise Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Answer 4 Exercise Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: Answer \\(G = (A+B) C D E\\) Exercise Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A \\, and \\, B) \\, or \\, C\\) Exercise Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Exercise Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \\(Z = \\bar{A} + B + \\bar{C} + D\\) Answer \"1010\" Pergunta Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \\(A . (\\bar{A} + B)= A . B\\) \\(A + (\\bar{A} . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Answer \\(A + (\\bar{A} . B) = A\\) Exercise Simplifique a seguinte express\u00e3o: \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Answer \\(\\bar{C} + \\bar{A} B C\\) Exercise Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: Exercise Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Exercise Crie o mapa de Karnaugh da tabela verdade de quatro entradas. A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Exercise Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) Exercise A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize-a. \\((A+B+C)(A+B+\\bar{C})(A+\\bar{B}+C)(\\bar{A}+B+C)(\\bar{A}+\\bar{B}+C)\\) dica: Equa\u00e7\u00e3o -> tabela verdade -> soma dos produtos Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"Tabela verdade"},{"location":"commum-content/exercicios/Exercicio-Algebra-Booleana-2/","text":"\u00c1lgebra Booleana - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Dado o circuito a seguir: Simplifique-o Desenhe o circuito simplificado Exercise Encontre a equa\u00e7\u00e3o dos mapas de K. a seguir: (TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. Exercise Detector de moedas Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 Exercise Impressora A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) Exercise SevenSeg Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo anodo comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"\u00c1lgebra Booleana - 2"},{"location":"commum-content/exercicios/Exercicio-Algebra-Booleana-2/#algebra-booleana-2","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Dado o circuito a seguir: Simplifique-o Desenhe o circuito simplificado Exercise Encontre a equa\u00e7\u00e3o dos mapas de K. a seguir: (TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. Exercise Detector de moedas Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 Exercise Impressora A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) Exercise SevenSeg Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo anodo comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"\u00c1lgebra Booleana - 2"},{"location":"commum-content/exercicios/Exercicio-CPU-1/","text":"Exercicio CPU - 1 \u00b6 Info Os problemas aqui descritos s\u00e3o os mesmo do final do LAB-15 . CPU \u00b6 Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU. Extras \u00b6 nop \u00b6 Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP? movw %D, %A e jg %D ao mesmo tempo \u00b6 Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ? loadPC \u00b6 Quais sinais o influenciam?","title":"Exercicio CPU - 1"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#exercicio-cpu-1","text":"Info Os problemas aqui descritos s\u00e3o os mesmo do final do LAB-15 .","title":"Exercicio CPU - 1"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#cpu","text":"Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU.","title":"CPU"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#extras","text":"","title":"Extras"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#nop","text":"Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP?","title":"nop"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#movw-d-a-e-jg-d-ao-mesmo-tempo","text":"Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ?","title":"movw %D, %A e jg %D ao mesmo tempo"},{"location":"commum-content/exercicios/Exercicio-CPU-1/#loadpc","text":"Quais sinais o influenciam?","title":"loadPC"},{"location":"commum-content/exercicios/Exercicio-CPU-2/","text":"Exercicio CPU - 2 \u00b6 falha 1 \u00b6 Note Para resolver o exerc\u00edcio a seguir voc\u00eas devem verificar a instru\u00e7\u00e3o que est\u00e1 sendo executada na CPU e o que ela deveria estar fazendo no hardawre. Voc\u00eas estavam desenvolvendo o projeto F quando o teste de integra\u00e7\u00e3o ./testeAssemblyMyCpu.py falhou no nasm descrito a seguir. Um colega do grupo enviou o waveform a seguir para voc\u00ea encontrar o problema (voc\u00ea deve falar o que est\u00e1 falhando). Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Essa simula\u00e7\u00e3o executa o programa a seguir: leaw $ 0 , % A movw ( % A ), % D leaw $ 1 , % A movw ( % A ), % A addw % A , % D , ( % A ) Que possui a RAM iniciada com os seguintes valores: Address Dado 0 0000000000000010 1 0000000001000010 3 0000000000000000 Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/erro-loadA.mp4 Engenharia reversa \u00b6 Voc\u00ea foi chamado para fazer engenharia reversa em um programa executando no HW do Z01, na captura de dados a equipe respons\u00e1vel n\u00e3o conseguiu capturar o sinal da Instru\u00e7\u00e3o, e n\u00e3o sabem quais comandos est\u00e3o sendo executados no computador. Encontre os tr\u00eas comandos em nasm que est\u00e3o sendo executados no hardware nesse momento: Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/eng-rev.mp4","title":"Exercicio CPU - 2"},{"location":"commum-content/exercicios/Exercicio-CPU-2/#exercicio-cpu-2","text":"","title":"Exercicio CPU - 2"},{"location":"commum-content/exercicios/Exercicio-CPU-2/#falha-1","text":"Note Para resolver o exerc\u00edcio a seguir voc\u00eas devem verificar a instru\u00e7\u00e3o que est\u00e1 sendo executada na CPU e o que ela deveria estar fazendo no hardawre. Voc\u00eas estavam desenvolvendo o projeto F quando o teste de integra\u00e7\u00e3o ./testeAssemblyMyCpu.py falhou no nasm descrito a seguir. Um colega do grupo enviou o waveform a seguir para voc\u00ea encontrar o problema (voc\u00ea deve falar o que est\u00e1 falhando). Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Essa simula\u00e7\u00e3o executa o programa a seguir: leaw $ 0 , % A movw ( % A ), % D leaw $ 1 , % A movw ( % A ), % A addw % A , % D , ( % A ) Que possui a RAM iniciada com os seguintes valores: Address Dado 0 0000000000000010 1 0000000001000010 3 0000000000000000 Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/erro-loadA.mp4","title":"falha 1"},{"location":"commum-content/exercicios/Exercicio-CPU-2/#engenharia-reversa","text":"Voc\u00ea foi chamado para fazer engenharia reversa em um programa executando no HW do Z01, na captura de dados a equipe respons\u00e1vel n\u00e3o conseguiu capturar o sinal da Instru\u00e7\u00e3o, e n\u00e3o sabem quais comandos est\u00e3o sendo executados no computador. Encontre os tr\u00eas comandos em nasm que est\u00e3o sendo executados no hardware nesse momento: Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/eng-rev.mp4","title":"Engenharia reversa"},{"location":"commum-content/exercicios/Exercicio-Dados-1/","text":"Dados Digitais - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00famerio bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII; https://docs.google.com/spreadsheets/d/1rN_zQqYaVI8PjAhKqEBCmY-_06I0X9dD0RddcI-miJs/edit?usp=sharing","title":"Dados Digitais - 1"},{"location":"commum-content/exercicios/Exercicio-Dados-1/#dados-digitais-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00famerio bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII; https://docs.google.com/spreadsheets/d/1rN_zQqYaVI8PjAhKqEBCmY-_06I0X9dD0RddcI-miJs/edit?usp=sharing","title":"Dados Digitais - 1"},{"location":"commum-content/exercicios/Exercicio-Dados-2/","text":"Dados Digitais - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Mem\u00f3ria 1 \u00b6 Mem\u00f3ria 2 \u00b6 Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII. 7 Segmentos \u00b6 O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (fachas) que estariam sendo exibidos no display! Octal \u00b6 Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Dados Digitais - 2"},{"location":"commum-content/exercicios/Exercicio-Dados-2/#dados-digitais-2","text":"Vers\u00e3o para impress\u00e3o.","title":"Dados Digitais - 2"},{"location":"commum-content/exercicios/Exercicio-Dados-2/#memoria-1","text":"","title":"Mem\u00f3ria 1"},{"location":"commum-content/exercicios/Exercicio-Dados-2/#memoria-2","text":"Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII.","title":"Mem\u00f3ria 2"},{"location":"commum-content/exercicios/Exercicio-Dados-2/#7-segmentos","text":"O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (fachas) que estariam sendo exibidos no display!","title":"7 Segmentos"},{"location":"commum-content/exercicios/Exercicio-Dados-2/#octal","text":"Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Octal"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-1/","text":"L\u00f3gica Sequencial - 1 \u00b6 https://docs.google.com/forms/d/e/1FAIpQLSdGuoLR1Re3aok6I6adChgaDuMg0-dJaA7FF2gK5MLIGReg3g/viewform?usp=sf_link Loading\u2026","title":"L\u00f3gica Sequencial - 1"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-1/#logica-sequencial-1","text":"https://docs.google.com/forms/d/e/1FAIpQLSdGuoLR1Re3aok6I6adChgaDuMg0-dJaA7FF2gK5MLIGReg3g/viewform?usp=sf_link Loading\u2026","title":"L\u00f3gica Sequencial - 1"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Indique o nome dos elementos l\u00f3gicos a seguir: \u00b6 Tabela verdade \u00b6 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \u00b6 \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obtem: \u00b6 \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \u00b6 \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Qual forma can\u00f4nica est\u00e1 correta? \u00b6 A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): \u00b6 A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana. Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \u00b6 \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos? \u00b6 Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois. Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: \u00b6 Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \u00b6 \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A and B) or C\\) Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \u00b6 \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \u00b6 \\(Z = \\bar{A} + B + \\bar{C} + D\\) Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \u00b6 \\(A . (\\bar{A} + B)= A . B\\) \\(A + (A . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Simplifique a seguinte express\u00e3o: \u00b6 \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: \u00b6 \\newpage Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. \u00b6 A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Crie o mapa de Karnaugh da tabela verdade de quatro entradas. \u00b6 A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \u00b6 \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela. \u00b6 _ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#indique-o-nome-dos-elementos-logicos-a-seguir","text":"","title":"Indique o nome dos elementos l\u00f3gicos a seguir:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#tabela-verdade","text":"A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage","title":"Tabela verdade"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#aplicando-a-lei-da-distributividade-na-expressao-abbarcd-se-tem","text":"\\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\)","title":"Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\)\u00a0se tem:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#aplicando-o-teorema-de-demorgan-na-expressao-overlineabc-obtem","text":"\\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\)","title":"Aplicando o teorema de DeMorgan na express\u00e3o\u00a0\\(\\overline{ABC}\\), obtem:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#qual-simplificacao-esta-incorreta","text":"\\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\)","title":"Qual simplifica\u00e7\u00e3o est\u00e1 incorreta:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#qual-forma-canonica-esta-correta","text":"A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\)","title":"Qual forma can\u00f4nica est\u00e1 correta?"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#dado-a-seguinte-tabela-verdade-entradas-a-b-e-c-e-a-saida-q","text":"A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana.","title":"Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q):"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#quantas-saidas-com-1-existem-na-tabela-verdade-que-resulta-na-seguinte-formula-de-soma-de-produtos","text":"\\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\)","title":"Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#qual-das-seguintes-opcoes-e-uma-caracteristica-importante-da-forma-canonica-de-soma-de-produtos","text":"Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois.","title":"Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos?"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#qual-e-a-expressao-em-algebra-booleana-do-seguinte-circuito","text":"","title":"Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#gere-a-tabela-verdade-das-equacoes-a-seguir","text":"\\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A and B) or C\\)","title":"Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#converta-a-seguinte-expressao-em-soma-de-produtos-para-produto-de-somas","text":"\\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS","title":"Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#determine-os-valores-de-a-b-c-e-d-que-fazem-a-formula-a-seguir-ser-igual-a-zero-z-0","text":"\\(Z = \\bar{A} + B + \\bar{C} + D\\)","title":"Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0)."},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#qual-das-seguintes-propriedades-da-algebra-booleana-e-falsa","text":"\\(A . (\\bar{A} + B)= A . B\\) \\(A + (A . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\)","title":"Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#simplifique-a-seguinte-expressao","text":"\\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\)","title":"Simplifique a seguinte express\u00e3o:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#encontre-as-equacoes-para-os-mapas-de-karnaugh-a-seguir","text":"\\newpage","title":"Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-e-encontre-a-equacao-da-tabela-verdade-a-seguir","text":"A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0","title":"Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir."},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-da-tabela-verdade-de-quatro-entradas","text":"A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1","title":"Crie o mapa de Karnaugh da tabela verdade de quatro entradas."},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-para-a-expressao-a-seguir-e-simplifique","text":"\\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\)","title":"Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique:"},{"location":"commum-content/exercicios/Exercicio-Logica-Sequencial-2/#a-seguinte-expressao-foi-resultado-da-forma-canonica-do-produto-de-somas-de-uma-tabela-verdade-para-a-producao-de-um-circuito-logico-o-objetivo-e-simplificar-a-algebra-booleana-dessa-logica-para-o-menor-numero-possivel-de-portas-porem-visivelmente-quem-fez-essa-formula-nao-percebeu-que-se-tivesse-feito-a-soma-de-produtos-ja-partiria-com-um-numero-menor-de-termos-converta-essa-formula-para-a-soma-de-produtos-e-minimize-ela","text":"_ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela."},{"location":"commum-content/exercicios/Exercicio-Sincrono-1/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Flip-Flop \u00b6 Um flip-flop tipo D possui entradas: clock , D , clear , preset e as sa\u00eddas Q e \\(\\bar{Q}\\) , explique quais s\u00e3o os papeis de cada uma das portas desse componente: Explique o papel das portas: clock : D : Clear : Preset : Q : not(Q) : Preencha a tabela verdade a seguir:","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Sincrono-1/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o","title":"\u00c1lgebra Booleana - 1"},{"location":"commum-content/exercicios/Exercicio-Sincrono-1/#flip-flop","text":"Um flip-flop tipo D possui entradas: clock , D , clear , preset e as sa\u00eddas Q e \\(\\bar{Q}\\) , explique quais s\u00e3o os papeis de cada uma das portas desse componente: Explique o papel das portas: clock : D : Clear : Preset : Q : not(Q) : Preencha a tabela verdade a seguir:","title":"Flip-Flop"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/","text":"\u00c1lgebra Booleana \u00b6 Conte\u00fado: Equa\u00e7\u00f5es; Opera\u00e7\u00f5es (portas l\u00f3gicas); Tabela Verdade; Sintetiza\u00e7\u00e3o de fun\u00e7\u00f5es; Soma dos Produtos; Produto das Somas; Simplifica\u00e7\u00e3o Alg\u00e9brica; Mapa de Karnaught. Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos. Video Progress Cheguei Aqui! Equa\u00e7\u00f5es \u00b6 Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A . B Note A opera\u00e7\u00e3o . \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo simbolo: ^ X = A and B X = A . B X = A ^ B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o TODOS os valor da sa\u00edda X com todas as entradas possiveis: A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade , e ser\u00e1 muito utilizada ao longo do curso. Tamb\u00e9m podemos representar essa equa\u00e7\u00e3o X = A . B como sendo um circuito digital: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas. Video Progress Cheguei Aqui! Opera\u00e7\u00f5es \u00b6 O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor . Video NOT \u00b6 O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac : X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade: Entrada A X = not A 0 1 1 0 Simbologia: AND \u00b6 O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ : X = A and B / X = A . B / X = A ^ B Tabela Verdade: A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia: OR \u00b6 O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v : X = A or B / X = A + B / X = A v B Tabela Verdade: A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia: NAND \u00b6 Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade: A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia: NOR / XOR / XNOR \u00b6 Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Estudar as portas pois iremos precisar que voc\u00eas saibam. CheckPoint O que \u00e9 correto afirmar sobre bits? Pode assumir 4 valores: 0, 1, 2, 3 \u00c9 utilizado pelos computadores para armazenar dados Representa dois estados: Ligado/ Desligado \u00c9 um estilo musical Answer . CheckPoint Qual o resultado de: y = 1 and 0 1 0 Answer . CheckPoint Qual o resultado de: y = 1 or 0 1 0 Answer . Progress Cheguei Aqui! Tabela Verdade \u00b6 Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Exercise \u00c9 correto afirmar sobre a tabela verdade: ((pode existir mais de um item correto) \u00c9 uma equa\u00e7\u00e3o l\u00f3gica Cada linha representa uma combina\u00e7\u00e3o de entrada \u00c9 um forma gr\u00e1fica de representar um circuito l\u00f3gico Possui todas as combina\u00e7\u00f5es de entradas e sa\u00edda poss\u00edvel Answer . Exercise Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? 2 linhas 4 linhas 8 linhas 16 linhas Answer 2^4 = 16 Exercise \ufeffQual tabela verdade a seguir foi montada correta? Answer . Exercise Considerando a equa\u00e7\u00e3o: X = not(B) + A, e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 0; 0; 0; 1 1; 0; 1; 1 1; 1; 1; 1 0; 0; 1; 1 Answer . Progress Cheguei Aqui! Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade \u00b6 Video \u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS) Soma Dos Produtos \u00b6 Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o. Produto das somas \u00b6 X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Exercise \ufeffQual forma \u00e9 a mais adequada para tabela verdade em quest\u00e3o? Soma dos produtos: (...) + (...) + Produto das somas: (+++) . (+++) . Answer . Exercise \ufeffQual forma \u00e9 a mais adequada para tabela verdade em quest\u00e3o? Soma dos produtos: (...) + (...) + Produto das somas: (+++) . (+++) . Answer . Exercise Qual equa\u00e7\u00e3o representa a tabela verdade? \\(x = (A + \\bar{B}).(\\bar{A} + \\bar{B})\\) \\(x = (A + B).(\\bar{A} + B)\\) \\(x = (\\bar{A} + B).(A + B)\\) Answer . Exercise Qual equa\u00e7\u00e3o representa a tabela verdade? \\(x = \\bar{A} . B\\) \\(x = A. \\bar{B}\\) \\(x = \\bar{A} . \\bar{B}\\) \\(x = A . B\\) Answer . Progress Cheguei Aqui! Simplifica\u00e7\u00e3o \u00b6 Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes. Simplifica\u00e7\u00e3o alg\u00e9brica \u00b6 Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Propriedade Opera\u00e7\u00e3o Lei da Identidade A = A \\(\\bar{A} = \\bar{A}\\) Lei da Comutatividade A . B = B . A A + B = B + A Lei da Associatividade A . (B . C) = A B C A + (B + C) = A + B + C Lei da Idempot\u00eancia A . A = A A + A = A Lei do Complemento Duplo \\(\\overline{\\overline{A}} = A\\) Lei da Complementariedade \\(A \\, \\overline{A} = 0\\) \\(A + \\overline{A} = 1\\) Lei da Intersec\u00e7\u00e3o A . 1 = A A . 0 = 0 Lei da Uni\u00e3o A + 1 = 1 A + 0 = A Lei da Distributividade A . (B + C) = (A . B) + (A . C) A + (B . C) = (A + B) (A + C) Teorema de DeMorgan \\(\\overline{A \\, B} = \\bar{A} + \\bar{B}\\) \\(\\overline{A + B} = \\bar{A} \\, \\bar{B}\\) Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: \\(A . B + A . C\\) -> \\(A (B + C)\\) Minimize o uso de 'portas l\u00f3gicas' exe: \\((A . B) . C + A . B . D\\) -> \\((A . B)(C + D)\\) Elimine minimize as entradas necess\u00e1rias exe: \\(( (A + \\overline{A}).B)\\) -> \\(B\\) Progress Cheguei Aqui! Exemplos \u00b6 Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada: Mapa de Karnaugh (MK) \u00b6 A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es Video 2. Criando o Mapa \u00b6 O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Exercise Qual mapa de K. foi montado certo? Answer . Exercise Qual mapa de K. foi montado certo? Answer . Progress Cheguei Aqui! 3. Grupos \u00b6 No MK podemos agrupar '1's na quantidade de: \\(2^n\\) , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Exercise Qual agrupamento \u00e9 o mais correto? Answer . Exercise Qual agrupamento \u00e9 o mais correto? Answer . Progress Cheguei Aqui! 4. Gerando as equa\u00e7\u00f5es \u00b6 Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\(\\bar{A}.B + \\bar{A} . \\bar{B}\\) que pode ser reduzida para \\(\\bar{A} (\\bar{B} + B)\\) e ent\u00e3o para: \\(\\bar{A}\\) O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: \\(F = 1\\) . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"\u00c1lgebra Booleana"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#algebra-booleana","text":"Conte\u00fado: Equa\u00e7\u00f5es; Opera\u00e7\u00f5es (portas l\u00f3gicas); Tabela Verdade; Sintetiza\u00e7\u00e3o de fun\u00e7\u00f5es; Soma dos Produtos; Produto das Somas; Simplifica\u00e7\u00e3o Alg\u00e9brica; Mapa de Karnaught. Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos. Video Progress Cheguei Aqui!","title":"\u00c1lgebra Booleana"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#equacoes","text":"Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A . B Note A opera\u00e7\u00e3o . \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo simbolo: ^ X = A and B X = A . B X = A ^ B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o TODOS os valor da sa\u00edda X com todas as entradas possiveis: A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade , e ser\u00e1 muito utilizada ao longo do curso. Tamb\u00e9m podemos representar essa equa\u00e7\u00e3o X = A . B como sendo um circuito digital: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas. Video Progress Cheguei Aqui!","title":"Equa\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#operacoes","text":"O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor . Video","title":"Opera\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#not","text":"O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac : X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade: Entrada A X = not A 0 1 1 0 Simbologia:","title":"NOT"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#and","text":"O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ : X = A and B / X = A . B / X = A ^ B Tabela Verdade: A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia:","title":"AND"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#or","text":"O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v : X = A or B / X = A + B / X = A v B Tabela Verdade: A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia:","title":"OR"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#nand","text":"Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade: A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia:","title":"NAND"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#nor-xor-xnor","text":"Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Estudar as portas pois iremos precisar que voc\u00eas saibam. CheckPoint O que \u00e9 correto afirmar sobre bits? Pode assumir 4 valores: 0, 1, 2, 3 \u00c9 utilizado pelos computadores para armazenar dados Representa dois estados: Ligado/ Desligado \u00c9 um estilo musical Answer . CheckPoint Qual o resultado de: y = 1 and 0 1 0 Answer . CheckPoint Qual o resultado de: y = 1 or 0 1 0 Answer . Progress Cheguei Aqui!","title":"NOR / XOR / XNOR"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#tabela-verdade","text":"Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Exercise \u00c9 correto afirmar sobre a tabela verdade: ((pode existir mais de um item correto) \u00c9 uma equa\u00e7\u00e3o l\u00f3gica Cada linha representa uma combina\u00e7\u00e3o de entrada \u00c9 um forma gr\u00e1fica de representar um circuito l\u00f3gico Possui todas as combina\u00e7\u00f5es de entradas e sa\u00edda poss\u00edvel Answer . Exercise Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? 2 linhas 4 linhas 8 linhas 16 linhas Answer 2^4 = 16 Exercise \ufeffQual tabela verdade a seguir foi montada correta? Answer . Exercise Considerando a equa\u00e7\u00e3o: X = not(B) + A, e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 0; 0; 0; 1 1; 0; 1; 1 1; 1; 1; 1 0; 0; 1; 1 Answer . Progress Cheguei Aqui!","title":"Tabela Verdade"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#funcoes-geradas-a-partir-de-tabelas-verdade","text":"Video \u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS)","title":"Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#soma-dos-produtos","text":"Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o.","title":"Soma Dos Produtos"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#produto-das-somas","text":"X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Exercise \ufeffQual forma \u00e9 a mais adequada para tabela verdade em quest\u00e3o? Soma dos produtos: (...) + (...) + Produto das somas: (+++) . (+++) . Answer . Exercise \ufeffQual forma \u00e9 a mais adequada para tabela verdade em quest\u00e3o? Soma dos produtos: (...) + (...) + Produto das somas: (+++) . (+++) . Answer . Exercise Qual equa\u00e7\u00e3o representa a tabela verdade? \\(x = (A + \\bar{B}).(\\bar{A} + \\bar{B})\\) \\(x = (A + B).(\\bar{A} + B)\\) \\(x = (\\bar{A} + B).(A + B)\\) Answer . Exercise Qual equa\u00e7\u00e3o representa a tabela verdade? \\(x = \\bar{A} . B\\) \\(x = A. \\bar{B}\\) \\(x = \\bar{A} . \\bar{B}\\) \\(x = A . B\\) Answer . Progress Cheguei Aqui!","title":"Produto das somas"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#simplificacao","text":"Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes.","title":"Simplifica\u00e7\u00e3o"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#simplificacao-algebrica","text":"Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Propriedade Opera\u00e7\u00e3o Lei da Identidade A = A \\(\\bar{A} = \\bar{A}\\) Lei da Comutatividade A . B = B . A A + B = B + A Lei da Associatividade A . (B . C) = A B C A + (B + C) = A + B + C Lei da Idempot\u00eancia A . A = A A + A = A Lei do Complemento Duplo \\(\\overline{\\overline{A}} = A\\) Lei da Complementariedade \\(A \\, \\overline{A} = 0\\) \\(A + \\overline{A} = 1\\) Lei da Intersec\u00e7\u00e3o A . 1 = A A . 0 = 0 Lei da Uni\u00e3o A + 1 = 1 A + 0 = A Lei da Distributividade A . (B + C) = (A . B) + (A . C) A + (B . C) = (A + B) (A + C) Teorema de DeMorgan \\(\\overline{A \\, B} = \\bar{A} + \\bar{B}\\) \\(\\overline{A + B} = \\bar{A} \\, \\bar{B}\\) Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: \\(A . B + A . C\\) -> \\(A (B + C)\\) Minimize o uso de 'portas l\u00f3gicas' exe: \\((A . B) . C + A . B . D\\) -> \\((A . B)(C + D)\\) Elimine minimize as entradas necess\u00e1rias exe: \\(( (A + \\overline{A}).B)\\) -> \\(B\\) Progress Cheguei Aqui!","title":"Simplifica\u00e7\u00e3o alg\u00e9brica"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#exemplos","text":"Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada:","title":"Exemplos"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#mapa-de-karnaugh-mk","text":"A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es Video","title":"Mapa de Karnaugh (MK)"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#2-criando-o-mapa","text":"O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Exercise Qual mapa de K. foi montado certo? Answer . Exercise Qual mapa de K. foi montado certo? Answer . Progress Cheguei Aqui!","title":"2. Criando o Mapa"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#3-grupos","text":"No MK podemos agrupar '1's na quantidade de: \\(2^n\\) , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Exercise Qual agrupamento \u00e9 o mais correto? Answer . Exercise Qual agrupamento \u00e9 o mais correto? Answer . Progress Cheguei Aqui!","title":"3. Grupos"},{"location":"commum-content/teoria/Teoria-Algebra-Booleana/#4-gerando-as-equacoes","text":"Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\(\\bar{A}.B + \\bar{A} . \\bar{B}\\) que pode ser reduzida para \\(\\bar{A} (\\bar{B} + B)\\) e ent\u00e3o para: \\(\\bar{A}\\) O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: \\(F = 1\\) . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"4. Gerando as equa\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria-HW/","text":"Aritm\u00e9tica Bin\u00e1ria - HW \u00b6 Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo principal \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar com n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder. half-adder (HAD) \u00b6 Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HAD possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado em hardware da seguinte maneira: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) full-adder (FAD) \u00b6 Video Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199. Somador \u00b6 Video Utilizando o FAD somos capazes de realizar um somador de dois vetores bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso com a liga\u00e7\u00e3o descrita a seguir: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria-HW/#aritmetica-binaria-hw","text":"Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo principal \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar com n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder.","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria-HW/#half-adder-had","text":"Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HAD possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado em hardware da seguinte maneira: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics )","title":"half-adder (HAD)"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria-HW/#full-adder-fad","text":"Video Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199.","title":"full-adder (FAD)"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria-HW/#somador","text":"Video Utilizando o FAD somos capazes de realizar um somador de dois vetores bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso com a liga\u00e7\u00e3o descrita a seguir: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Somador"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/","text":"Aritm\u00e9tica Bin\u00e1ria \u00b6 Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Video Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais fracionados (exemplo: -15 ; 1,032 ; -0,0001 ; 10001231231 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 Video A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos refor\u00e7ar que 1+1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 10 + 10 = 100 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Precisamos entender que cada bit deve ser armazenado em hardware! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. Note Os bits s\u00e3o armazenados na mem\u00f3ria, as mem\u00f3rias armazenam vetores de bits. Computadores reais n\u00e3o possuem mem\u00f3ria infinita e nem largura de bits infinita. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido x \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 Complemento de um \u00b6 Warning Forma errada/ n\u00e3o usual de armazenar n\u00fameros sinalizados (+, -) Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos No complemento de um , utilizamos a casa/bit mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 8 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111 Complemento de 2 \u00b6 Video O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui alguams vantagens: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo \u2194 negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rio (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplo: -3 = 11111101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 111111011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona porque n\u00e3o cabe) (exemplo com 4 bits!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 <-- 7 !! (n\u00e3o funcionou) ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100 Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2 \u00b6 Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100 Ponto fixo \u00b6 Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s). Ponto flutuante \u00b6 Ponto flutuante \u00e9 uma outra nota\u00e7\u00e3o na qual \u00e9 poss\u00edvel representar n\u00fameros racionais digitalmente (bin\u00e1rio), nessa t\u00e9cnica a v\u00edrgula n\u00e3o \u00e9 fixa, e a nota\u00e7\u00e3o pode se adequar para armazenar n\u00fameros muito trandes ou muito pequenos. No entanto, existe um custo computacional mais elevado envolvido nisso. Processadores modernos possuem um hardware (ULA) dedicada a realizar opera\u00e7\u00f5es em ponto flutuante, normalmente usando o padr\u00e3o IEEE 754 .","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#aritmetica-binaria","text":"Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Video Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais fracionados (exemplo: -15 ; 1,032 ; -0,0001 ; 10001231231 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#soma-binaria","text":"Video A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos refor\u00e7ar que 1+1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 10 + 10 = 100 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Precisamos entender que cada bit deve ser armazenado em hardware! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. Note Os bits s\u00e3o armazenados na mem\u00f3ria, as mem\u00f3rias armazenam vetores de bits. Computadores reais n\u00e3o possuem mem\u00f3ria infinita e nem largura de bits infinita. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido x \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#complemento-de-um","text":"Warning Forma errada/ n\u00e3o usual de armazenar n\u00fameros sinalizados (+, -) Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos No complemento de um , utilizamos a casa/bit mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 8 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111","title":"Complemento de um"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#complemento-de-2","text":"Video O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui alguams vantagens: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo \u2194 negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rio (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplo: -3 = 11111101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 111111011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona porque n\u00e3o cabe) (exemplo com 4 bits!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 <-- 7 !! (n\u00e3o funcionou) ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100","title":"Complemento de 2"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#multiplicacao-divisao-por-multiplo-de-2","text":"Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100","title":"Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#ponto-fixo","text":"Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s).","title":"Ponto fixo"},{"location":"commum-content/teoria/Teoria-Aritmetica-Binaria/#ponto-flutuante","text":"Ponto flutuante \u00e9 uma outra nota\u00e7\u00e3o na qual \u00e9 poss\u00edvel representar n\u00fameros racionais digitalmente (bin\u00e1rio), nessa t\u00e9cnica a v\u00edrgula n\u00e3o \u00e9 fixa, e a nota\u00e7\u00e3o pode se adequar para armazenar n\u00fameros muito trandes ou muito pequenos. No entanto, existe um custo computacional mais elevado envolvido nisso. Processadores modernos possuem um hardware (ULA) dedicada a realizar opera\u00e7\u00f5es em ponto flutuante, normalmente usando o padr\u00e3o IEEE 754 .","title":"Ponto flutuante"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/","text":"Tabela de S\u00edmbolos \u00b6 O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo. S\u00edmbolos padr\u00f5es \u00b6 Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 Labels \u00b6 S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp Endere\u00e7os de mem\u00f3ria \u00b6 S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis no START_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label. Exemplo \u00b6 Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x , %A 1: movw $1 , ( %A ) 2: LOOP: 3: leaw $UPDATE , %A 4: je %D 5: nop 6: leaw $temp , %A 7: movw ( %A ), %A 8: addw %A , %S , %S 9: decw %D 10: leaw $LOOP , %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3 , %A 15: movw %S , ( %A ) 16: END: 17: leaw $END , %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deve ser: |S\u00edmbolos | Valor | |------------|--------| | R0 | 0 | | R1 | 1 | | ... | ... | | R15 | 15 | | SP | 0 | | LCL | 1 | | ARG | 2 | | THIS | 3 | | THAT | 4 | | SCREEN | 16384 | | LED | 21184 | | SW | 21185 | |------------|--------| | x | 16 | | y | 17 | | LOOP | 2 | | UPDATE | 12 | | END | 14 |","title":"Tabela de S\u00edmbolos"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/#tabela-de-simbolos","text":"O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo.","title":"Tabela de S\u00edmbolos"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/#simbolos-padroes","text":"Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185","title":"S\u00edmbolos padr\u00f5es"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/#labels","text":"S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp","title":"Labels"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/#enderecos-de-memoria","text":"S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis no START_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"commum-content/teoria/Teoria-Assembler-SymbolTable/#exemplo","text":"Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x , %A 1: movw $1 , ( %A ) 2: LOOP: 3: leaw $UPDATE , %A 4: je %D 5: nop 6: leaw $temp , %A 7: movw ( %A ), %A 8: addw %A , %S , %S 9: decw %D 10: leaw $LOOP , %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3 , %A 15: movw %S , ( %A ) 16: END: 17: leaw $END , %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deve ser: |S\u00edmbolos | Valor | |------------|--------| | R0 | 0 | | R1 | 1 | | ... | ... | | R15 | 15 | | SP | 0 | | LCL | 1 | | ARG | 2 | | THIS | 3 | | THAT | 4 | | SCREEN | 16384 | | LED | 21184 | | SW | 21185 | |------------|--------| | x | 16 | | y | 17 | | LOOP | 2 | | UPDATE | 12 | | END | 14 |","title":"Exemplo"},{"location":"commum-content/teoria/Teoria-Assembler/","text":"Assembler \u00b6 EDSAC O EDSAC (Electronic Delay Storage Automatic Calculator) \u00e9 creditado como um dos primeiros computadores a utilizar um Assembler. https://people.cs.clemson.edu/~mark/edsac.html Grace Hopper Foi uma das primeiras pessoas a programar os computadores Mark I, Mark II, Mark III, UNIVAC I e UNIVAC II o que tornou ela uma das grandes pioneiras da computa\u00e7\u00e3o e seus trabalhos influenciaram futuras gera\u00e7\u00f5es. Ela desenvolveu compiladores como o A-O e B-O que levaram ao desenvolvimento do COBOL, que foi usada durante muito tempo em diversos sistemas computacionais e ainda hoje, possui uso em sistemas cr\u00edticos de governos e institui\u00e7\u00f5es financeiras ao redor do mundo. Tamb\u00e9m um fato curioso, \u00e9 que o primeiro bug de computadores se atribui a ela, no caso ela encontrou uma mariposa preso a um relay do Mark II que interrompeu uma execu\u00e7\u00e3o de um programa dela. https://en.wikipedia.org/wiki/Grace_Hopper Linguagens Assembly s\u00e3o as representa\u00e7\u00f5es simb\u00f3licas dos comandos bin\u00e1rios do computador (linguagem de m\u00e1quina), facilitando o desenvolvimento de programas. Essa \u00e9 uma linguagem que chamamos de baixo n\u00edvel, ou seja, ela n\u00e3o \u00e9 t\u00e3o sofisticada como uma linguagem Java onde os comandos abstraem o hardware, e n\u00e3o possuem uma rela\u00e7\u00e3o direta com o hardware. Em geral instru\u00e7\u00f5es Assembly s\u00e3o convertidas diretamente para uma instru\u00e7\u00e3o de linguagem de m\u00e1quina. Podemos dizer que \u00e9 um mapeamento um para um, assim cada instru\u00e7\u00e3o Assembly vira uma instru\u00e7\u00e3o de m\u00e1quina. O que um assembler faz? \u00b6 Assembler Em portugu\u00eas \u00e9 conhecido como montador . As CPUs tem suas linguagens m\u00e1quinas, que s\u00e3o descritas pelas sequ\u00eancias de bits, ou seja, seus 0 s e 1 s. O assembly \u00e9 um formalismo que permite a cria\u00e7\u00e3o dos programas em uma linguagem mais humanamente trat\u00e1vel, por\u00e9m os computadores n\u00e3o conseguem executar diretamente esse tipo de instru\u00e7\u00e3o, uma s\u00e9rie de tratamentos e convers\u00f5es s\u00e3o necess\u00e1rias e o que o Assembler faz \u00e9 justamente traduzir essa linguagem de mnem\u00f4nicos para os c\u00f3digos bin\u00e1rios da arquitetura em quest\u00e3o, ou seja, os 0 s e 1 s que o computador consegue diretamente executar. Tip Os Assemblers presentes nos sistemas operacionais dispon\u00edveis s\u00e3o normalmente o NASM para a sintaxe intel e o GAS para a sintaxe AT&T, mas podem haver varia\u00e7\u00f5es. http://www.ibm.com/developerworks/library/l-gas-nasm/ Etapas de montagem \u00b6 O montador proposto nesse curso tem as seguintes etapas: Abrir arquivo An\u00e1lise sint\u00e1tica Parsing (Tabela de S\u00edmbolos) Gera\u00e7\u00e3o de c\u00f3digo (code) An\u00e1lise Sint\u00e1tica \u00b6 O assemble faz a an\u00e1lise sint\u00e1tica (parsing) dos arquivos, identificando cada sequencia de caracteres, e posteriormente gerando os c\u00f3digos bin\u00e1rios para uma determinada arquitetura. Fazer o Parsing significa detectar cada s\u00edmbolo para determinar a estrutura sint\u00e1tica de uma express\u00e3o, que \u00e9 escrita de acordo com as regras de uma determinada gram\u00e1tica. Para analisar essa express\u00e3o, voc\u00ea tem que dividi-la no que chamamos de tokens: S\u00edmbolos \u00b6 Uma das dificuldades em se programar em Assembly est\u00e1 relacionada ao gerenciamento de mem\u00f3ria, ou seja, como saber em que endere\u00e7o de mem\u00f3ria devemos armazenar um valor ou para qual endere\u00e7o realizar um salto, ou seja, um JUMP, ou Branching. Para isso podemos usar refer\u00eancias simb\u00f3licas nos programas para endere\u00e7ar mem\u00f3rias f\u00edsicas no computador. Usamos uma vari\u00e1vel como em linguagens de alto n\u00edvel e esses s\u00edmbolos s\u00e3o posteriormente convertidos em n\u00fameros pelo Assembler. leaw $ END , % A Para as vari\u00e1veis de valores podemos escolher endere\u00e7os seguindo alguma regra, que posteriormente podem ser recuperados e armazenados em uma tabela que relaciona o nome ao valor. leaw $ var1 , % A movw % D , ( % A ) J\u00e1 para os saltos, como a tradu\u00e7\u00e3o do Assembly \u00e9 direta, ou seja, as instru\u00e7\u00f5es em Assembly se mapeiam em instru\u00e7\u00f5es em linguagem de m\u00e1quina como uma fun\u00e7\u00e3o bijetora, A tabela de s\u00edmbolos pode ser usada para localizar onde est\u00e3o marcados os marcadores que vamos chamar aqui de Labels e tamb\u00e9m armazenar na mem\u00f3ria. Finalmente vale ressaltar que a tabela de s\u00edmbolos muitas vezes vem com uma s\u00e9rie de s\u00edmbolos pr\u00e9 definidos, que podem acessar posi\u00e7\u00f5es de mem\u00f3ria padronizadas para algo espec\u00edfico da arquitetura. leaw $ R0 , % A leaw $ LED , % A O programa assembler varre o c\u00f3digo em busca desses s\u00edmbolos e cria uma tabela relacionando o seu nome a um valor que pode ser convertido em bin\u00e1rio: Sempre que o assembler encontrar um s\u00edmbolo, ele consulta essa tabela em busca do valor associado a ele. Gera\u00e7\u00e3o de c\u00f3digo \u00b6 O assembler necessita ler os opcodes e transformar em linguagem de m\u00e1quina. \u00c9 essa etapa que ir\u00e1 realmente criar uma sa\u00edda bin\u00e1ria. A gera\u00e7\u00e3o de c\u00f3digo deve identificar o tipo do comando que est\u00e1 sendo executado, os seus par\u00e2metros e s\u00edmbolos e ent\u00e3o gerar a sa\u00edda bin\u00e1ria com base no instruction set de refer\u00eancia. Ferramental do curso \u00b6 Desenvolvemos no projeto E-Assembly uma s\u00e9rie de programas escritos em nasm, mas voc\u00ea j\u00e1 parou para pensar como esses programas s\u00e3o montados? Quando voc\u00eas executam o script ./testeAssembly.py algumas coisas acontecem: O script abre o arquivo de configura\u00e7\u00f5es de teste: config.txt e busca quais m\u00f3dulos nasm deve compilar Para cada arquivo .nasm encontrado \u00e9 chamado um programa em java que \u00e9 o assembler, exemplo: Elementos BCC $ java -jar ~/Z01-Tools/jar/Z01-Assembler.jar -i ./src/add.nasm -o /bin/add.hack $ ./bits.py assembler from-nasm sw/assembly/add.nasm add.hack Tip Experimente voc\u00ea rodar esse comando e ver o que ele gera de output. O programa em Java est\u00e1 dentro da pasta Z01-Tools/jar na raiz do usu\u00e1rio de voc\u00eas no linux. Esse programa em Java implementa o Assembler, e gera para cada nasm passado um execut\u00e1vel. O script de teste n\u00e3o para por a\u00ed, ele precisa agora pegar esse execut\u00e1vel, junto com os testes e jogar no Hardware, executar e pegar o resultado.","title":"Assembler"},{"location":"commum-content/teoria/Teoria-Assembler/#assembler","text":"EDSAC O EDSAC (Electronic Delay Storage Automatic Calculator) \u00e9 creditado como um dos primeiros computadores a utilizar um Assembler. https://people.cs.clemson.edu/~mark/edsac.html Grace Hopper Foi uma das primeiras pessoas a programar os computadores Mark I, Mark II, Mark III, UNIVAC I e UNIVAC II o que tornou ela uma das grandes pioneiras da computa\u00e7\u00e3o e seus trabalhos influenciaram futuras gera\u00e7\u00f5es. Ela desenvolveu compiladores como o A-O e B-O que levaram ao desenvolvimento do COBOL, que foi usada durante muito tempo em diversos sistemas computacionais e ainda hoje, possui uso em sistemas cr\u00edticos de governos e institui\u00e7\u00f5es financeiras ao redor do mundo. Tamb\u00e9m um fato curioso, \u00e9 que o primeiro bug de computadores se atribui a ela, no caso ela encontrou uma mariposa preso a um relay do Mark II que interrompeu uma execu\u00e7\u00e3o de um programa dela. https://en.wikipedia.org/wiki/Grace_Hopper Linguagens Assembly s\u00e3o as representa\u00e7\u00f5es simb\u00f3licas dos comandos bin\u00e1rios do computador (linguagem de m\u00e1quina), facilitando o desenvolvimento de programas. Essa \u00e9 uma linguagem que chamamos de baixo n\u00edvel, ou seja, ela n\u00e3o \u00e9 t\u00e3o sofisticada como uma linguagem Java onde os comandos abstraem o hardware, e n\u00e3o possuem uma rela\u00e7\u00e3o direta com o hardware. Em geral instru\u00e7\u00f5es Assembly s\u00e3o convertidas diretamente para uma instru\u00e7\u00e3o de linguagem de m\u00e1quina. Podemos dizer que \u00e9 um mapeamento um para um, assim cada instru\u00e7\u00e3o Assembly vira uma instru\u00e7\u00e3o de m\u00e1quina.","title":"Assembler"},{"location":"commum-content/teoria/Teoria-Assembler/#o-que-um-assembler-faz","text":"Assembler Em portugu\u00eas \u00e9 conhecido como montador . As CPUs tem suas linguagens m\u00e1quinas, que s\u00e3o descritas pelas sequ\u00eancias de bits, ou seja, seus 0 s e 1 s. O assembly \u00e9 um formalismo que permite a cria\u00e7\u00e3o dos programas em uma linguagem mais humanamente trat\u00e1vel, por\u00e9m os computadores n\u00e3o conseguem executar diretamente esse tipo de instru\u00e7\u00e3o, uma s\u00e9rie de tratamentos e convers\u00f5es s\u00e3o necess\u00e1rias e o que o Assembler faz \u00e9 justamente traduzir essa linguagem de mnem\u00f4nicos para os c\u00f3digos bin\u00e1rios da arquitetura em quest\u00e3o, ou seja, os 0 s e 1 s que o computador consegue diretamente executar. Tip Os Assemblers presentes nos sistemas operacionais dispon\u00edveis s\u00e3o normalmente o NASM para a sintaxe intel e o GAS para a sintaxe AT&T, mas podem haver varia\u00e7\u00f5es. http://www.ibm.com/developerworks/library/l-gas-nasm/","title":"O que um assembler faz?"},{"location":"commum-content/teoria/Teoria-Assembler/#etapas-de-montagem","text":"O montador proposto nesse curso tem as seguintes etapas: Abrir arquivo An\u00e1lise sint\u00e1tica Parsing (Tabela de S\u00edmbolos) Gera\u00e7\u00e3o de c\u00f3digo (code)","title":"Etapas de montagem"},{"location":"commum-content/teoria/Teoria-Assembler/#analise-sintatica","text":"O assemble faz a an\u00e1lise sint\u00e1tica (parsing) dos arquivos, identificando cada sequencia de caracteres, e posteriormente gerando os c\u00f3digos bin\u00e1rios para uma determinada arquitetura. Fazer o Parsing significa detectar cada s\u00edmbolo para determinar a estrutura sint\u00e1tica de uma express\u00e3o, que \u00e9 escrita de acordo com as regras de uma determinada gram\u00e1tica. Para analisar essa express\u00e3o, voc\u00ea tem que dividi-la no que chamamos de tokens:","title":"An\u00e1lise Sint\u00e1tica"},{"location":"commum-content/teoria/Teoria-Assembler/#simbolos","text":"Uma das dificuldades em se programar em Assembly est\u00e1 relacionada ao gerenciamento de mem\u00f3ria, ou seja, como saber em que endere\u00e7o de mem\u00f3ria devemos armazenar um valor ou para qual endere\u00e7o realizar um salto, ou seja, um JUMP, ou Branching. Para isso podemos usar refer\u00eancias simb\u00f3licas nos programas para endere\u00e7ar mem\u00f3rias f\u00edsicas no computador. Usamos uma vari\u00e1vel como em linguagens de alto n\u00edvel e esses s\u00edmbolos s\u00e3o posteriormente convertidos em n\u00fameros pelo Assembler. leaw $ END , % A Para as vari\u00e1veis de valores podemos escolher endere\u00e7os seguindo alguma regra, que posteriormente podem ser recuperados e armazenados em uma tabela que relaciona o nome ao valor. leaw $ var1 , % A movw % D , ( % A ) J\u00e1 para os saltos, como a tradu\u00e7\u00e3o do Assembly \u00e9 direta, ou seja, as instru\u00e7\u00f5es em Assembly se mapeiam em instru\u00e7\u00f5es em linguagem de m\u00e1quina como uma fun\u00e7\u00e3o bijetora, A tabela de s\u00edmbolos pode ser usada para localizar onde est\u00e3o marcados os marcadores que vamos chamar aqui de Labels e tamb\u00e9m armazenar na mem\u00f3ria. Finalmente vale ressaltar que a tabela de s\u00edmbolos muitas vezes vem com uma s\u00e9rie de s\u00edmbolos pr\u00e9 definidos, que podem acessar posi\u00e7\u00f5es de mem\u00f3ria padronizadas para algo espec\u00edfico da arquitetura. leaw $ R0 , % A leaw $ LED , % A O programa assembler varre o c\u00f3digo em busca desses s\u00edmbolos e cria uma tabela relacionando o seu nome a um valor que pode ser convertido em bin\u00e1rio: Sempre que o assembler encontrar um s\u00edmbolo, ele consulta essa tabela em busca do valor associado a ele.","title":"S\u00edmbolos"},{"location":"commum-content/teoria/Teoria-Assembler/#geracao-de-codigo","text":"O assembler necessita ler os opcodes e transformar em linguagem de m\u00e1quina. \u00c9 essa etapa que ir\u00e1 realmente criar uma sa\u00edda bin\u00e1ria. A gera\u00e7\u00e3o de c\u00f3digo deve identificar o tipo do comando que est\u00e1 sendo executado, os seus par\u00e2metros e s\u00edmbolos e ent\u00e3o gerar a sa\u00edda bin\u00e1ria com base no instruction set de refer\u00eancia.","title":"Gera\u00e7\u00e3o de c\u00f3digo"},{"location":"commum-content/teoria/Teoria-Assembler/#ferramental-do-curso","text":"Desenvolvemos no projeto E-Assembly uma s\u00e9rie de programas escritos em nasm, mas voc\u00ea j\u00e1 parou para pensar como esses programas s\u00e3o montados? Quando voc\u00eas executam o script ./testeAssembly.py algumas coisas acontecem: O script abre o arquivo de configura\u00e7\u00f5es de teste: config.txt e busca quais m\u00f3dulos nasm deve compilar Para cada arquivo .nasm encontrado \u00e9 chamado um programa em java que \u00e9 o assembler, exemplo: Elementos BCC $ java -jar ~/Z01-Tools/jar/Z01-Assembler.jar -i ./src/add.nasm -o /bin/add.hack $ ./bits.py assembler from-nasm sw/assembly/add.nasm add.hack Tip Experimente voc\u00ea rodar esse comando e ver o que ele gera de output. O programa em Java est\u00e1 dentro da pasta Z01-Tools/jar na raiz do usu\u00e1rio de voc\u00eas no linux. Esse programa em Java implementa o Assembler, e gera para cada nasm passado um execut\u00e1vel. O script de teste n\u00e3o para por a\u00ed, ele precisa agora pegar esse execut\u00e1vel, junto com os testes e jogar no Hardware, executar e pegar o resultado.","title":"Ferramental do curso"},{"location":"commum-content/teoria/Teoria-Assembly/","text":"ASM - Assembly \u00b6 Assembly \u00e9 a linguagem de programa\u00e7\u00e3o mais pr\u00f3xima do hardware, nela cada linha de c\u00f3digo \u00e9 traduzida diretamente para um linha do execut\u00e1vel (c\u00f3digo bin\u00e1rio). Para mais informa\u00e7\u00f5es sobre o assembly utilizado no curso acesse a p\u00e1gina: Z01 Resumo Assembly . Exemplo: INICIO: leaw $ 0 , % A movw % A , % D ; Carrega 0 em S ADD: ; Label para saltar incw % D ; Incrementa S leaw $ ADD , % A ; Carrega endere\u00e7o do label ADD ; (3 no caso) jmp ; Salto incondicional nop ; No-Operation ; (necess\u00e1rio ap\u00f3s jump)","title":"ASM - Assembly"},{"location":"commum-content/teoria/Teoria-Assembly/#asm-assembly","text":"Assembly \u00e9 a linguagem de programa\u00e7\u00e3o mais pr\u00f3xima do hardware, nela cada linha de c\u00f3digo \u00e9 traduzida diretamente para um linha do execut\u00e1vel (c\u00f3digo bin\u00e1rio). Para mais informa\u00e7\u00f5es sobre o assembly utilizado no curso acesse a p\u00e1gina: Z01 Resumo Assembly . Exemplo: INICIO: leaw $ 0 , % A movw % A , % D ; Carrega 0 em S ADD: ; Label para saltar incw % D ; Incrementa S leaw $ ADD , % A ; Carrega endere\u00e7o do label ADD ; (3 no caso) jmp ; Salto incondicional nop ; No-Operation ; (necess\u00e1rio ap\u00f3s jump)","title":"ASM - Assembly"},{"location":"commum-content/teoria/Teoria-CMOS/","text":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor) \u00b6 Conte\u00fado: CMOS Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/CMOS Transistores MOS \u00b6 Os transistores MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor) s\u00e3o os mais utilizados nos circuitos integrados anal\u00f3gicos e digitais, sendo que seu princ\u00edpio b\u00e1sico foi proposto por Julius Edgar Lilienfeld em 1926. Mas, foi s\u00f3 em 1960 que esse transistor foi produzido. Seu princ\u00edpio de funcionamento de baseia na presen\u00e7a de um capacitor MOS (Metal-Oxide-Semiconductor) que controla a quantidade de cargas na regi\u00e3o semicondutora, chamada de canal. Os transistores MOS podem ser classificados de acordo com o portador de cargas: transistor nMOS onde a corrente \u00e9 conduzida por el\u00e9trons e transistor pMOS onde a corrente \u00e9 conduzida por lacunas. Para que esses dispositivos operem como chave, \u00e9 necess\u00e1ria a aplica\u00e7\u00e3o de uma tens\u00e3o de forma a atrair os portadores de corrente. Assim, no nMOS uma tens\u00e3o positiva entre porta e fonte atrai el\u00e9trons para o canal, enquanto que no pMOS uma tens\u00e3o negativa entre porta e fonte deve ser aplicada para atrair cargas positivas para a regi\u00e3o do canal. Tecnologia CMOS \u00b6 A tecnologia CMOS (Complementary MOS) \u00e9 um tipo de processo de fabrica\u00e7\u00e3o criado na d\u00e9cada de 60, que utiliza pares sim\u00e9tricos e complementares de nMOS e pMOS para realizar fun\u00e7\u00f5es l\u00f3gicas. Para a an\u00e1lise dos circuitos l\u00f3gicos CMOS, pode-se considerar que quando a tens\u00e3o na porta de um nMOS foi positiva, ele se comporta como uma chave fechada e, quando a tens\u00e3o for nula, se comporta como uma chave aberta. Para o pMOS, o comportamento \u00e9 oposto: se comporta como chave fechada para a tens\u00e3o nula e aberta para a tens\u00e3o positiva. L\u00f3gica NOT \u00b6 Quando ambos os transistores est\u00e3o ligados em s\u00e9rie como apresentado na figura, ao se aplicar uma tens\u00e3o de entrada positiva, o nMOS (transistor inferior) se comporta como chave fechada enquanto o pMOS (transistor superior) se comporta como chave aberta. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 nula. Ao se aplicar uma tens\u00e3o de entrada nula, o nMOS passa a se comportar como chave aberta enquanto o pMOS se comporta como chave fechada. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 positiva. Pode-se observar que o circuito opera como um inversor. L\u00f3gica NAND \u00b6 Para formar a porta l\u00f3gica NAND, dois transistores nMOS s\u00e3o ligados em s\u00e9rie enquanto que dois pMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. L\u00f3gica NOR \u00b6 Para formar a porta l\u00f3gica NOR, dois transistores pMOS s\u00e3o ligados em s\u00e9rie enquanto que dois nMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. As demais porta l\u00f3gicas podem ser criadas a partir dessas fundamentais.","title":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor)"},{"location":"commum-content/teoria/Teoria-CMOS/#logica-cmos-complementary-metaloxidesemiconductor","text":"Conte\u00fado: CMOS Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/CMOS","title":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor)"},{"location":"commum-content/teoria/Teoria-CMOS/#transistores-mos","text":"Os transistores MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor) s\u00e3o os mais utilizados nos circuitos integrados anal\u00f3gicos e digitais, sendo que seu princ\u00edpio b\u00e1sico foi proposto por Julius Edgar Lilienfeld em 1926. Mas, foi s\u00f3 em 1960 que esse transistor foi produzido. Seu princ\u00edpio de funcionamento de baseia na presen\u00e7a de um capacitor MOS (Metal-Oxide-Semiconductor) que controla a quantidade de cargas na regi\u00e3o semicondutora, chamada de canal. Os transistores MOS podem ser classificados de acordo com o portador de cargas: transistor nMOS onde a corrente \u00e9 conduzida por el\u00e9trons e transistor pMOS onde a corrente \u00e9 conduzida por lacunas. Para que esses dispositivos operem como chave, \u00e9 necess\u00e1ria a aplica\u00e7\u00e3o de uma tens\u00e3o de forma a atrair os portadores de corrente. Assim, no nMOS uma tens\u00e3o positiva entre porta e fonte atrai el\u00e9trons para o canal, enquanto que no pMOS uma tens\u00e3o negativa entre porta e fonte deve ser aplicada para atrair cargas positivas para a regi\u00e3o do canal.","title":"Transistores MOS"},{"location":"commum-content/teoria/Teoria-CMOS/#tecnologia-cmos","text":"A tecnologia CMOS (Complementary MOS) \u00e9 um tipo de processo de fabrica\u00e7\u00e3o criado na d\u00e9cada de 60, que utiliza pares sim\u00e9tricos e complementares de nMOS e pMOS para realizar fun\u00e7\u00f5es l\u00f3gicas. Para a an\u00e1lise dos circuitos l\u00f3gicos CMOS, pode-se considerar que quando a tens\u00e3o na porta de um nMOS foi positiva, ele se comporta como uma chave fechada e, quando a tens\u00e3o for nula, se comporta como uma chave aberta. Para o pMOS, o comportamento \u00e9 oposto: se comporta como chave fechada para a tens\u00e3o nula e aberta para a tens\u00e3o positiva.","title":"Tecnologia CMOS"},{"location":"commum-content/teoria/Teoria-CMOS/#logica-not","text":"Quando ambos os transistores est\u00e3o ligados em s\u00e9rie como apresentado na figura, ao se aplicar uma tens\u00e3o de entrada positiva, o nMOS (transistor inferior) se comporta como chave fechada enquanto o pMOS (transistor superior) se comporta como chave aberta. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 nula. Ao se aplicar uma tens\u00e3o de entrada nula, o nMOS passa a se comportar como chave aberta enquanto o pMOS se comporta como chave fechada. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 positiva. Pode-se observar que o circuito opera como um inversor.","title":"L\u00f3gica NOT"},{"location":"commum-content/teoria/Teoria-CMOS/#logica-nand","text":"Para formar a porta l\u00f3gica NAND, dois transistores nMOS s\u00e3o ligados em s\u00e9rie enquanto que dois pMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor.","title":"L\u00f3gica NAND"},{"location":"commum-content/teoria/Teoria-CMOS/#logica-nor","text":"Para formar a porta l\u00f3gica NOR, dois transistores pMOS s\u00e3o ligados em s\u00e9rie enquanto que dois nMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. As demais porta l\u00f3gicas podem ser criadas a partir dessas fundamentais.","title":"L\u00f3gica NOR"},{"location":"commum-content/teoria/Teoria-Componentes/","text":"Componentes Digitais \u00b6 Aqui iremos alguns dos in\u00fameros componentes combinacionais (n\u00e3o precisam de clock) que s\u00e3o utilizados no desenvolvimento de circuitos digitais e que ser\u00e3o usados na disciplina. portas l\u00f3gicas \u00b6 VHDL MyHDL S <= A and B ; S <= A nand B ; S <= not ( A and B ) S <= A or B ; S <= A nor B ; S <= not ( A or B ); S <= A xor B ; S <= ( not A ); S = A and B S = not ( A and B ) S = A or B S = not ( A or B ) S = A ^ B S = not B Multiplexado (mux) \u00b6 fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. VHDL MyHDL entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; @block def mux2Way ( in0 , in1 , sel , o ): @always_comb def comb (): if sel == 0 : o . next = in0 else : o . next = in1 return comb O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 2^3 linhas (o seletor conta como entrada), totalizando 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz ( 0 ou 1 ), logo cada linha que possui X seria expandida para duas linhas. Tip O tamanho do seletor deve ser um numero inteiro: \\(log2(size(n))\\) . | Quantidade de entras | Tamanho do seletor | | ------------------- | ------------------ | | 2 | 1 | | 3 | 2 | | 4 | 2 | | 5 | 3 | | 8 | 3 | Demutiplexador (demux) \u00b6 \u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. VHDL MyHDL entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; @block def deMux2Way ( in0 , sel , out0 , out1 ): @always_comb def comb (): if sel == 0 : out0 . next = a out1 . next = 0 else : out0 . next = 0 out1 . next = a return comb A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0 Enconders \u00b6 Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder BCD \u00b6 Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| VHDL MyHDL entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; @block def binaryToBCD ( x , out0 , out1 ): @always_comb def comb (): ... return comb Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials C\u00f3digo Gray \u00b6 O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh Comparador \u00b6 Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| VHDL MyHDL entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ; @block def binaryToBCD ( x , eq , gt ): @always_comb def comb (): gt = 1 if x > 0 else 0 eq = 1 if x == 0 else 0 return comb Somadores \u00b6 Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| VHDL MyHDL entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; @block def adder ( in1 , in2 , o ): @always_comb def comb (): o = in1 + in2 return comb Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Componentes Digitais"},{"location":"commum-content/teoria/Teoria-Componentes/#componentes-digitais","text":"Aqui iremos alguns dos in\u00fameros componentes combinacionais (n\u00e3o precisam de clock) que s\u00e3o utilizados no desenvolvimento de circuitos digitais e que ser\u00e3o usados na disciplina.","title":"Componentes Digitais"},{"location":"commum-content/teoria/Teoria-Componentes/#portas-logicas","text":"VHDL MyHDL S <= A and B ; S <= A nand B ; S <= not ( A and B ) S <= A or B ; S <= A nor B ; S <= not ( A or B ); S <= A xor B ; S <= ( not A ); S = A and B S = not ( A and B ) S = A or B S = not ( A or B ) S = A ^ B S = not B","title":"portas l\u00f3gicas"},{"location":"commum-content/teoria/Teoria-Componentes/#multiplexado-mux","text":"fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. VHDL MyHDL entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; @block def mux2Way ( in0 , in1 , sel , o ): @always_comb def comb (): if sel == 0 : o . next = in0 else : o . next = in1 return comb O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 2^3 linhas (o seletor conta como entrada), totalizando 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz ( 0 ou 1 ), logo cada linha que possui X seria expandida para duas linhas. Tip O tamanho do seletor deve ser um numero inteiro: \\(log2(size(n))\\) . | Quantidade de entras | Tamanho do seletor | | ------------------- | ------------------ | | 2 | 1 | | 3 | 2 | | 4 | 2 | | 5 | 3 | | 8 | 3 |","title":"Multiplexado (mux)"},{"location":"commum-content/teoria/Teoria-Componentes/#demutiplexador-demux","text":"\u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. VHDL MyHDL entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; @block def deMux2Way ( in0 , sel , out0 , out1 ): @always_comb def comb (): if sel == 0 : out0 . next = a out1 . next = 0 else : out0 . next = 0 out1 . next = a return comb A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0","title":"Demutiplexador (demux)"},{"location":"commum-content/teoria/Teoria-Componentes/#enconders","text":"Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder","title":"Enconders"},{"location":"commum-content/teoria/Teoria-Componentes/#bcd","text":"Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| VHDL MyHDL entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; @block def binaryToBCD ( x , out0 , out1 ): @always_comb def comb (): ... return comb Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials","title":"BCD"},{"location":"commum-content/teoria/Teoria-Componentes/#codigo-gray","text":"O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh","title":"C\u00f3digo Gray"},{"location":"commum-content/teoria/Teoria-Componentes/#comparador","text":"Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| VHDL MyHDL entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ; @block def binaryToBCD ( x , eq , gt ): @always_comb def comb (): gt = 1 if x > 0 else 0 eq = 1 if x == 0 else 0 return comb","title":"Comparador"},{"location":"commum-content/teoria/Teoria-Componentes/#somadores","text":"Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| VHDL MyHDL entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; @block def adder ( in1 , in2 , o ): @always_comb def comb (): o = in1 + in2 return comb Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Somadores"},{"location":"commum-content/teoria/Teoria-Dados/","text":"Dados Digitais \u00b6 Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) ---------------- -------------------------------------------------------------------------------------------------------------------- KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida de quatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. ![](http://people.idsia.ch/~juergen/schickardcomputer178e.jpg){width=200} > Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. ![](https://images.computerhistory.org/revonline/images/500004213-03-01.jpg?w=600){width=200} > Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m, foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. ![](https://images.computerhistory.org/revonline/images/102630768-03-01.jpg?w=600){width=300} > Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar oralmente/escrito. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 10 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem \\(10^n\\) : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. ![](https://cdn.britannica.com/60/91960-004-42DF23AB.gif) > Fonte: https://kids.britannica.com/kids/assembly/view/89478 Base 2 \u00b6 No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nessa base, cada posi\u00e7\u00e3o possui um peso da ordem \\(2^n\\) : Video Dessa maneira podemos construir o valor que desejarmos de decimal ( \\(m\\) ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar \\(ceil(log2(m))\\) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio \\(0 .. 1\\) 1 \\(0 .. 3\\) ceil(log2(4)) = 2 \\(0 .. 4\\) 2 \\(0 .. 6\\) 3 \\(0 .. 7\\) 3 \\(0 .. 15\\) 4 \\(0 .. 31\\) 5 \\(0 .. 63\\) 6 \\(0 .. 127\\) 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1ria pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com \\(n\\) bits: $0 .. 2^n-1$ Nomenclatura Iremos utilizar os prefixos: - ` `: Para indicar um n\u00famero em decimal - `0b`: Para indicar um n\u00famero em bin\u00e1rio - `0x`: Para indicar um n\u00famero em hexadecimal Exemplo: ``` hex bin dec 0x100 != 0b100 != 100 ``` Base 2 Converta 15 de decimal para base 2 (bin\u00e1rio) - [ ] `0015` - [x] `1111` - [ ] `1110` - [ ] `1101` !!! answer ``` 8+4+2+1 = 15 1 1 1 1 ``` Defini\u00e7\u00f5es \u00b6 Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word Convers\u00e3o Decimal <-> Bin\u00e1rio \u00b6 Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa. Video Video Base 16 \u00b6 Video A base 16, ou hexadecimal, \u00e9 outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma \\(2^{16}\\) : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10 Base 16 \u2194 Base 2 \u00b6 Video A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice-versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_0000_0001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58 Base 16 \u2194 Base 10 \u00b6 Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0xA01 para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^0 -> 10.256 + 0.16 + 1.1 = 2561 Para alterar a base de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits Base 8 \u00b6 Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: \\(8^n\\) . Veja o exemplo a seguir: a) 137 em octal para decimal: \\(1.8^2 + 3.8^1 + 7.8^0=95\\) 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 \\(64+24+7=95\\) Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permiss\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do Norte, M\u00e9xico e Europa utilizam o sistema octal, pois consideram a quantidade dos v\u00e3os dos dedos e n\u00e3o os dedos propriamente. > Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal. Outros sistemas \u00b6 Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8 BCD \u00b6 No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD Video ASCII \u00b6 ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal): Video","title":"Dados Digitais"},{"location":"commum-content/teoria/Teoria-Dados/#dados-digitais","text":"Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) ---------------- -------------------------------------------------------------------------------------------------------------------- KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida de quatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. ![](http://people.idsia.ch/~juergen/schickardcomputer178e.jpg){width=200} > Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. ![](https://images.computerhistory.org/revonline/images/500004213-03-01.jpg?w=600){width=200} > Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m, foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. ![](https://images.computerhistory.org/revonline/images/102630768-03-01.jpg?w=600){width=300} > Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar oralmente/escrito. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 10 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem \\(10^n\\) : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. ![](https://cdn.britannica.com/60/91960-004-42DF23AB.gif) > Fonte: https://kids.britannica.com/kids/assembly/view/89478","title":"Dados Digitais"},{"location":"commum-content/teoria/Teoria-Dados/#base-2","text":"No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nessa base, cada posi\u00e7\u00e3o possui um peso da ordem \\(2^n\\) : Video Dessa maneira podemos construir o valor que desejarmos de decimal ( \\(m\\) ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar \\(ceil(log2(m))\\) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio \\(0 .. 1\\) 1 \\(0 .. 3\\) ceil(log2(4)) = 2 \\(0 .. 4\\) 2 \\(0 .. 6\\) 3 \\(0 .. 7\\) 3 \\(0 .. 15\\) 4 \\(0 .. 31\\) 5 \\(0 .. 63\\) 6 \\(0 .. 127\\) 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1ria pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com \\(n\\) bits: $0 .. 2^n-1$ Nomenclatura Iremos utilizar os prefixos: - ` `: Para indicar um n\u00famero em decimal - `0b`: Para indicar um n\u00famero em bin\u00e1rio - `0x`: Para indicar um n\u00famero em hexadecimal Exemplo: ``` hex bin dec 0x100 != 0b100 != 100 ``` Base 2 Converta 15 de decimal para base 2 (bin\u00e1rio) - [ ] `0015` - [x] `1111` - [ ] `1110` - [ ] `1101` !!! answer ``` 8+4+2+1 = 15 1 1 1 1 ```","title":"Base 2"},{"location":"commum-content/teoria/Teoria-Dados/#definicoes","text":"Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word","title":"Defini\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-Dados/#conversao-decimal-binario","text":"Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa. Video Video","title":"Convers\u00e3o Decimal &lt;-&gt; Bin\u00e1rio"},{"location":"commum-content/teoria/Teoria-Dados/#base-16","text":"Video A base 16, ou hexadecimal, \u00e9 outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma \\(2^{16}\\) : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10","title":"Base 16"},{"location":"commum-content/teoria/Teoria-Dados/#base-16-base-2","text":"Video A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice-versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_0000_0001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58","title":"Base 16 &lt;--&gt; Base 2"},{"location":"commum-content/teoria/Teoria-Dados/#base-16-base-10","text":"Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0xA01 para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^0 -> 10.256 + 0.16 + 1.1 = 2561 Para alterar a base de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits","title":"Base 16 &lt;--&gt; Base 10"},{"location":"commum-content/teoria/Teoria-Dados/#base-8","text":"Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: \\(8^n\\) . Veja o exemplo a seguir: a) 137 em octal para decimal: \\(1.8^2 + 3.8^1 + 7.8^0=95\\) 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 \\(64+24+7=95\\) Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permiss\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do Norte, M\u00e9xico e Europa utilizam o sistema octal, pois consideram a quantidade dos v\u00e3os dos dedos e n\u00e3o os dedos propriamente. > Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal.","title":"Base 8"},{"location":"commum-content/teoria/Teoria-Dados/#outros-sistemas","text":"Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8","title":"Outros sistemas"},{"location":"commum-content/teoria/Teoria-Dados/#bcd","text":"No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD Video","title":"BCD"},{"location":"commum-content/teoria/Teoria-Dados/#ascii","text":"ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal): Video","title":"ASCII"},{"location":"commum-content/teoria/Teoria-Linguagem-de-Maquina/","text":"Linguagem de m\u00e1quina \u00b6 Um programa em c\u00f3digo de m\u00e1quina consiste em uma sequ\u00eancia de bytes que correspondem a instru\u00e7\u00f5es que ser\u00e3o executadas pelo processador. As instru\u00e7\u00f5es do processador, chamadas de opcodes, s\u00e3o representadas por valores em hexadecimal. Fonte: https://pt.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina \u00c9 o que efetivamente ser\u00e1 convertido em bin\u00e1rio e gravado na mem\u00f3ria de programa para ser lido e interpretado pela CPU. Essa convers\u00e3o \u00e9 realizada normalmente um por software chamado de Assembler ou Montador. Ele \u00e9 respons\u00e1vel por converter os OPCODES ( leaw ) no c\u00f3digo de m\u00e1quina ( 000000101010 ). Uma linguagem de m\u00e1quina \u00e9 espec\u00edfica para um Conjunto de instru\u00e7\u00f5es ( instruction set ), que define os recursos de hardware que uma determinada CPU oferece (uso de registradores, opera\u00e7\u00f5es aritm\u00e9ticas, opera\u00e7\u00f5es l\u00f3gicas, ...). Fabricantes de chips tendem a modificar o instruction set melhorando o HW entre gera\u00e7\u00f5es, essas mudan\u00e7as tem que ser feito de modo que permita que c\u00f3digos antigos executem em hardwares mais modernos (retrocompatibilidade). Defeito de ponto flutuante Em 1994, a Intel cometeu um erro no projeto do primeiro processador Pentium que causou um preju\u00edzo devido a um recall de US$ 450.000.000, esse bug de hardware fazia com que raramente uma conta de ponto flutuante tivesse resultado errado. Para saber mais a respeito: https://pt.wikipedia.org/wiki/Defeito_de_ponto_flutuante Pentium F00F bug \u00c9 um bug descoberto em 1997 que quando uma instru\u00e7\u00e3o espec\u00edfica: F0 0F C7 C8 fosse executada no hardawre, o mesmo travava e s\u00f3 voltava ao normal com um reset. Para saber mais a respeito: https://en.wikipedia.org/wiki/Pentium_F00F_bug Z01 \u00b6 A linguagem de m\u00e1quina utilizada no curso \u00e9 adaptada do livro Texto com umas pequenas mudan\u00e7as, ela possui 18 bits de largura e cada bit possui uma a\u00e7\u00e3o direta sobre a CPU, esse tipo de linguagem de m\u00e1quina \u00e9 chamado de microcode . Note CPUs mais complexas n\u00e3o possuem essa rela\u00e7\u00e3o de que cada bit da instru\u00e7\u00e3o controla algum funcionamento direto (sinal) da CPU. A seguir a defini\u00e7\u00e3o da linguagem de m\u00e1quina da nossa CPU: Instru\u00e7\u00f5es do tipo A \u00b6 Instru\u00e7\u00f5es do tipo A s\u00e3o aquelas que possibilitam o carregamento efetivo de um dado salvo no programa (ROM) para dentro da CPU. \u00c9 a maneira que possu\u00edmos de carregar uma constante no nosso hardware. Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 0 . No vers\u00e3o atual da CPU s\u00f3 possu\u00edmos uma instru\u00e7\u00e3o nessa categoria, a leaw . exemplo leaw $3, %A 000000000000000011 Instru\u00e7\u00f5es do tipo C \u00b6 Instru\u00e7\u00f5es do tipo C s\u00e3o aquelas que computam alguma coisa (n\u00famerico ou l\u00f3gico), movem dados, ou realizam mudan\u00e7as no Program Counter (salto / jump condicional ou n\u00e3o-condicional). Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 1 . Example addw %A, %D, %D 100000000100010000","title":"Linguagem de m\u00e1quina"},{"location":"commum-content/teoria/Teoria-Linguagem-de-Maquina/#linguagem-de-maquina","text":"Um programa em c\u00f3digo de m\u00e1quina consiste em uma sequ\u00eancia de bytes que correspondem a instru\u00e7\u00f5es que ser\u00e3o executadas pelo processador. As instru\u00e7\u00f5es do processador, chamadas de opcodes, s\u00e3o representadas por valores em hexadecimal. Fonte: https://pt.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina \u00c9 o que efetivamente ser\u00e1 convertido em bin\u00e1rio e gravado na mem\u00f3ria de programa para ser lido e interpretado pela CPU. Essa convers\u00e3o \u00e9 realizada normalmente um por software chamado de Assembler ou Montador. Ele \u00e9 respons\u00e1vel por converter os OPCODES ( leaw ) no c\u00f3digo de m\u00e1quina ( 000000101010 ). Uma linguagem de m\u00e1quina \u00e9 espec\u00edfica para um Conjunto de instru\u00e7\u00f5es ( instruction set ), que define os recursos de hardware que uma determinada CPU oferece (uso de registradores, opera\u00e7\u00f5es aritm\u00e9ticas, opera\u00e7\u00f5es l\u00f3gicas, ...). Fabricantes de chips tendem a modificar o instruction set melhorando o HW entre gera\u00e7\u00f5es, essas mudan\u00e7as tem que ser feito de modo que permita que c\u00f3digos antigos executem em hardwares mais modernos (retrocompatibilidade). Defeito de ponto flutuante Em 1994, a Intel cometeu um erro no projeto do primeiro processador Pentium que causou um preju\u00edzo devido a um recall de US$ 450.000.000, esse bug de hardware fazia com que raramente uma conta de ponto flutuante tivesse resultado errado. Para saber mais a respeito: https://pt.wikipedia.org/wiki/Defeito_de_ponto_flutuante Pentium F00F bug \u00c9 um bug descoberto em 1997 que quando uma instru\u00e7\u00e3o espec\u00edfica: F0 0F C7 C8 fosse executada no hardawre, o mesmo travava e s\u00f3 voltava ao normal com um reset. Para saber mais a respeito: https://en.wikipedia.org/wiki/Pentium_F00F_bug","title":"Linguagem de m\u00e1quina"},{"location":"commum-content/teoria/Teoria-Linguagem-de-Maquina/#z01","text":"A linguagem de m\u00e1quina utilizada no curso \u00e9 adaptada do livro Texto com umas pequenas mudan\u00e7as, ela possui 18 bits de largura e cada bit possui uma a\u00e7\u00e3o direta sobre a CPU, esse tipo de linguagem de m\u00e1quina \u00e9 chamado de microcode . Note CPUs mais complexas n\u00e3o possuem essa rela\u00e7\u00e3o de que cada bit da instru\u00e7\u00e3o controla algum funcionamento direto (sinal) da CPU. A seguir a defini\u00e7\u00e3o da linguagem de m\u00e1quina da nossa CPU:","title":"Z01"},{"location":"commum-content/teoria/Teoria-Linguagem-de-Maquina/#instrucoes-do-tipo-a","text":"Instru\u00e7\u00f5es do tipo A s\u00e3o aquelas que possibilitam o carregamento efetivo de um dado salvo no programa (ROM) para dentro da CPU. \u00c9 a maneira que possu\u00edmos de carregar uma constante no nosso hardware. Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 0 . No vers\u00e3o atual da CPU s\u00f3 possu\u00edmos uma instru\u00e7\u00e3o nessa categoria, a leaw . exemplo leaw $3, %A 000000000000000011","title":"Instru\u00e7\u00f5es do tipo A"},{"location":"commum-content/teoria/Teoria-Linguagem-de-Maquina/#instrucoes-do-tipo-c","text":"Instru\u00e7\u00f5es do tipo C s\u00e3o aquelas que computam alguma coisa (n\u00famerico ou l\u00f3gico), movem dados, ou realizam mudan\u00e7as no Program Counter (salto / jump condicional ou n\u00e3o-condicional). Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 1 . Example addw %A, %D, %D 100000000100010000","title":"Instru\u00e7\u00f5es do tipo C"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/","text":"L\u00f3gica Sequencial \u00b6 Video Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 este momento do curso s\u00f3 usamos circuitos criados com l\u00f3gica combinacional, por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessa l\u00f3gica uma tabela verdade define bem a sa\u00edda de um circuito. Nesses casos, podemos dizer que ao colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande maioria combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema. Circuitos biest\u00e1veis \u00b6 Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Neste circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\(\\bar{Q}\\) , que \u00e9 sempre o inverso do Q , se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: \\(S\\) \\(R\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Metaest\u00e1vel Oxford Languages: capaz de perder a estabilidade atrav\u00e9s de pequenas perturba\u00e7\u00f5es (diz-se de sistema f\u00edsico). No circuito anterior mestaest\u00e1vel indica que a sa\u00edda pode ser 0 ou 1 , e que n\u00e3o podemos prever qual ser\u00e1. Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: \\(E\\) \\(D\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrad D negada: 1 0 1 Copia Entrada D : 1 Copia Entrada D negada: 0 Video Clock \u00b6 Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos diferentes, mas precisa chegar na sa\u00edda ao mesmo tempo. Em hardware isso \u00e9 muito dif\u00edcil de prever/ controlar. A solu\u00e7\u00e3o utilizada nesses casos \u00e9 a de sincronizar os sinais com diferentes tempos de propaga\u00e7\u00e3o. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um pianista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso cada m\u00fasica possui um ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Frequ\u00eancia F=1/L Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) Video http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm Flip-Flop \u00b6 Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos explorar apenas o FF do tipo D. FF tipo D \u00b6 O FF tipo D possui as seguintes portas: \\(D\\) entrada do de Dado \\(Q\\) sa\u00edda do dado copiado \\(\\bar{Q}\\) sa\u00edda do dado copiado \\(CLK\\) entrada do clock Toda vez que o ocorre uma borda de subina no clock , o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9 representada da seguinte maneira: \\(D\\) (in) \\(clk\\) (in) \\(Q\\) (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente Clear e Preset \u00b6 FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: \\(D\\) (in) \\(clr\\) \\(set\\) \\(clk\\) (in) \\(Q\\) (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1 Video","title":"L\u00f3gica Sequencial"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#logica-sequencial","text":"Video Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 este momento do curso s\u00f3 usamos circuitos criados com l\u00f3gica combinacional, por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessa l\u00f3gica uma tabela verdade define bem a sa\u00edda de um circuito. Nesses casos, podemos dizer que ao colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande maioria combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema.","title":"L\u00f3gica Sequencial"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#circuitos-biestaveis","text":"Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Neste circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\(\\bar{Q}\\) , que \u00e9 sempre o inverso do Q , se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: \\(S\\) \\(R\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Metaest\u00e1vel Oxford Languages: capaz de perder a estabilidade atrav\u00e9s de pequenas perturba\u00e7\u00f5es (diz-se de sistema f\u00edsico). No circuito anterior mestaest\u00e1vel indica que a sa\u00edda pode ser 0 ou 1 , e que n\u00e3o podemos prever qual ser\u00e1. Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: \\(E\\) \\(D\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrad D negada: 1 0 1 Copia Entrada D : 1 Copia Entrada D negada: 0 Video","title":"Circuitos biest\u00e1veis"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#clock","text":"Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos diferentes, mas precisa chegar na sa\u00edda ao mesmo tempo. Em hardware isso \u00e9 muito dif\u00edcil de prever/ controlar. A solu\u00e7\u00e3o utilizada nesses casos \u00e9 a de sincronizar os sinais com diferentes tempos de propaga\u00e7\u00e3o. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um pianista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso cada m\u00fasica possui um ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Frequ\u00eancia F=1/L Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) Video http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm","title":"Clock"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#flip-flop","text":"Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos explorar apenas o FF do tipo D.","title":"Flip-Flop"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#ff-tipo-d","text":"O FF tipo D possui as seguintes portas: \\(D\\) entrada do de Dado \\(Q\\) sa\u00edda do dado copiado \\(\\bar{Q}\\) sa\u00edda do dado copiado \\(CLK\\) entrada do clock Toda vez que o ocorre uma borda de subina no clock , o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9 representada da seguinte maneira: \\(D\\) (in) \\(clk\\) (in) \\(Q\\) (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente","title":"FF tipo D"},{"location":"commum-content/teoria/Teoria-Logica-Sequencial/#clear-e-preset","text":"FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: \\(D\\) (in) \\(clr\\) \\(set\\) \\(clk\\) (in) \\(Q\\) (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1 Video","title":"Clear e Preset"},{"location":"commum-content/teoria/Teoria-Numeros-Binarios/","text":"N\u00fameros bin\u00e1rios \u00b6 Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 complemento de 1 \u00b6 Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1. Complemento de 2 \u00b6 O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"N\u00fameros bin\u00e1rios"},{"location":"commum-content/teoria/Teoria-Numeros-Binarios/#numeros-binarios","text":"Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"N\u00fameros bin\u00e1rios"},{"location":"commum-content/teoria/Teoria-Numeros-Binarios/#soma-binaria","text":"A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"commum-content/teoria/Teoria-Numeros-Binarios/#complemento-de-1","text":"Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1.","title":"complemento de 1"},{"location":"commum-content/teoria/Teoria-Numeros-Binarios/#complemento-de-2","text":"O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"Complemento de 2"},{"location":"commum-content/teoria/Teoria-RTL/","text":"Resistor-Transistor Logic (RTL) \u00b6 Conte\u00fado: RTL Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Leitura das p\u00e1ginas 1 - 13 (ler somente at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic Usando Transistores para recriar portas l\u00f3gicas \u00b6 O uso de transistores para cria\u00e7\u00e3o de portas l\u00f3gicas depende de seu uso como chave controlada eletronicamente. No transistor tipo BJT, quando o diodo na base-emissor est\u00e1 conduzindo, o transistor \u00e9 levado a satura\u00e7\u00e3o e a tens\u00e3o entre coletor e emissor se aproxima de zero. L\u00f3gica E - AND \u00b6 Para a l\u00f3gica E (AND), ambos transistores est\u00e3o em s\u00e9rie e ambos devem estar conduzindo para que a sa\u00edda (OUT) esteja em n\u00edvel ALTO. L\u00f3gica OU - OR \u00b6 Para a l\u00f3gica OU (OR), ambos transistores est\u00e3o em paralelo e enquanto pelo menos um deles estiver conduzindo, a sa\u00edda (OUT) ficara em n\u00edvel ALTO. L\u00f3gica N\u00c3O E - NAND \u00b6 Para a l\u00f3gica N\u00c3O E (NAND), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel ALTO a n\u00e3o ser que ambas entradas sejam colocadas em ALTO, no qual far\u00e1 que os transistores conduzam e levem a sa\u00edda para n\u00edvel BAIXO. L\u00f3gica N\u00c3O OU - NOR \u00b6 Para a l\u00f3gica N\u00c3O OU (NOR), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel BAIXO desde que um deles esteja conduzindo. Usando dois resistores no controle da base do transistor, \u00e9 poss\u00edvel recriar a porta NOR com apenas um transistor.","title":"Resistor-Transistor Logic (RTL)"},{"location":"commum-content/teoria/Teoria-RTL/#resistor-transistor-logic-rtl","text":"Conte\u00fado: RTL Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Leitura das p\u00e1ginas 1 - 13 (ler somente at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic","title":"Resistor-Transistor Logic (RTL)"},{"location":"commum-content/teoria/Teoria-RTL/#usando-transistores-para-recriar-portas-logicas","text":"O uso de transistores para cria\u00e7\u00e3o de portas l\u00f3gicas depende de seu uso como chave controlada eletronicamente. No transistor tipo BJT, quando o diodo na base-emissor est\u00e1 conduzindo, o transistor \u00e9 levado a satura\u00e7\u00e3o e a tens\u00e3o entre coletor e emissor se aproxima de zero.","title":"Usando Transistores para recriar portas l\u00f3gicas"},{"location":"commum-content/teoria/Teoria-RTL/#logica-e-and","text":"Para a l\u00f3gica E (AND), ambos transistores est\u00e3o em s\u00e9rie e ambos devem estar conduzindo para que a sa\u00edda (OUT) esteja em n\u00edvel ALTO.","title":"L\u00f3gica E - AND"},{"location":"commum-content/teoria/Teoria-RTL/#logica-ou-or","text":"Para a l\u00f3gica OU (OR), ambos transistores est\u00e3o em paralelo e enquanto pelo menos um deles estiver conduzindo, a sa\u00edda (OUT) ficara em n\u00edvel ALTO.","title":"L\u00f3gica OU - OR"},{"location":"commum-content/teoria/Teoria-RTL/#logica-nao-e-nand","text":"Para a l\u00f3gica N\u00c3O E (NAND), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel ALTO a n\u00e3o ser que ambas entradas sejam colocadas em ALTO, no qual far\u00e1 que os transistores conduzam e levem a sa\u00edda para n\u00edvel BAIXO.","title":"L\u00f3gica N\u00c3O E - NAND"},{"location":"commum-content/teoria/Teoria-RTL/#logica-nao-ou-nor","text":"Para a l\u00f3gica N\u00c3O OU (NOR), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel BAIXO desde que um deles esteja conduzindo. Usando dois resistores no controle da base do transistor, \u00e9 poss\u00edvel recriar a porta NOR com apenas um transistor.","title":"L\u00f3gica N\u00c3O OU - NOR"},{"location":"commum-content/teoria/Teoria-Sequencial-Componentes/","text":"Componentes S\u00edncronos \u00b6 Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3 Binary digit - bits \u00b6 Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : out = in out = out Registrador \u00b6 O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetor de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m*w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura! Mem\u00f3ria RAM \u00b6 Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Componentes S\u00edncronos"},{"location":"commum-content/teoria/Teoria-Sequencial-Componentes/#componentes-sincronos","text":"Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3","title":"Componentes S\u00edncronos"},{"location":"commum-content/teoria/Teoria-Sequencial-Componentes/#binary-digit-bits","text":"Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : out = in out = out","title":"Binary digit - bits"},{"location":"commum-content/teoria/Teoria-Sequencial-Componentes/#registrador","text":"O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetor de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m*w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura!","title":"Registrador"},{"location":"commum-content/teoria/Teoria-Sequencial-Componentes/#memoria-ram","text":"Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Mem\u00f3ria RAM"},{"location":"commum-content/teoria/Teoria-ULA/","text":"ULA \u00b6 Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Video Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46 Arquitetura \u00b6 A ULA utilizada no curso tem a seguinte arquitetura interna: Os sinais do diagrama s\u00e3o: X e Y : Entradas de 16 bits OUT : Sa\u00edda da ULA zx, nx, zy, ny, f, no : Sinais de controle da ULA zr e ng : Sa\u00edda de flags da ULA e que a opera\u00e7\u00e3o realizada na ULA: zr : resultou em zero ng : resultou em um n\u00famero negativo Opera\u00e7\u00f5es \u00b6 As opera\u00e7\u00f5es suportadas pela ULA s\u00e3o (OUT): 0 : Gera o valor 0 ( 000000000000000 ) 1 : Gera o n\u00famero 1 ( 000000000000001 ) -1 : Gera o n\u00famero -1 ( 111111111111111 ) X : Replica a entrada X Y : Replica a entrada Y !X : Inverte bit a bit a entrada X !Y : Inverte bit a bit a entrada Y -X : Nega (complemento de dois) a entrada X -Y : Nega (complemento de dois) a entrada Y X+1 : Soma um a entrada X Y+1 : Soma um a entrada Y X-1 : Subtrai um da entrada X Y-1 : Subtrai um da entrada Y X+Y : Soma as entradas X e Y X-Y : Subtrai Y de X Y-X : Subtrai X de Y Y&X : Realiza a opera AND bit a bit de X com Y Y|X : Realiza a opera or bit a bit de X com Y Controle \u00b6 Para realizar as opera\u00e7\u00f5es \u00e9 necess\u00e1rio controlar o sinais de controle da ULA, a tabela a seguir indica o que deve ser feito para cada umas das opera\u00e7\u00f5es suportadas: zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x | y Opera\u00e7\u00e3o n\u00e3o trivial \u00b6 A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: \\(y-x=\\overline{x+\\bar{y}}\\) esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\(\\bar{y}=-y-1\\) Substituindo: \\(\\overline{x+ (-y -1)}\\) Podemos chamar: \\(x+ (-y -1) = z\\) \\(\\overline{z}\\) , aplicando a mesma substitui\u00e7\u00e3o que 2. \\(\\overline{z}=-z-1\\) , recuperando z \\(-y-x=-(x -y -1)-1\\) \\(y-x=-x+y\\)","title":"ULA"},{"location":"commum-content/teoria/Teoria-ULA/#ula","text":"Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Video Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46","title":"ULA"},{"location":"commum-content/teoria/Teoria-ULA/#arquitetura","text":"A ULA utilizada no curso tem a seguinte arquitetura interna: Os sinais do diagrama s\u00e3o: X e Y : Entradas de 16 bits OUT : Sa\u00edda da ULA zx, nx, zy, ny, f, no : Sinais de controle da ULA zr e ng : Sa\u00edda de flags da ULA e que a opera\u00e7\u00e3o realizada na ULA: zr : resultou em zero ng : resultou em um n\u00famero negativo","title":"Arquitetura"},{"location":"commum-content/teoria/Teoria-ULA/#operacoes","text":"As opera\u00e7\u00f5es suportadas pela ULA s\u00e3o (OUT): 0 : Gera o valor 0 ( 000000000000000 ) 1 : Gera o n\u00famero 1 ( 000000000000001 ) -1 : Gera o n\u00famero -1 ( 111111111111111 ) X : Replica a entrada X Y : Replica a entrada Y !X : Inverte bit a bit a entrada X !Y : Inverte bit a bit a entrada Y -X : Nega (complemento de dois) a entrada X -Y : Nega (complemento de dois) a entrada Y X+1 : Soma um a entrada X Y+1 : Soma um a entrada Y X-1 : Subtrai um da entrada X Y-1 : Subtrai um da entrada Y X+Y : Soma as entradas X e Y X-Y : Subtrai Y de X Y-X : Subtrai X de Y Y&X : Realiza a opera AND bit a bit de X com Y Y|X : Realiza a opera or bit a bit de X com Y","title":"Opera\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-ULA/#controle","text":"Para realizar as opera\u00e7\u00f5es \u00e9 necess\u00e1rio controlar o sinais de controle da ULA, a tabela a seguir indica o que deve ser feito para cada umas das opera\u00e7\u00f5es suportadas: zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x | y","title":"Controle"},{"location":"commum-content/teoria/Teoria-ULA/#operacao-nao-trivial","text":"A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: \\(y-x=\\overline{x+\\bar{y}}\\) esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\(\\bar{y}=-y-1\\) Substituindo: \\(\\overline{x+ (-y -1)}\\) Podemos chamar: \\(x+ (-y -1) = z\\) \\(\\overline{z}\\) , aplicando a mesma substitui\u00e7\u00e3o que 2. \\(\\overline{z}=-z-1\\) , recuperando z \\(-y-x=-(x -y -1)-1\\) \\(y-x=-x+y\\)","title":"Opera\u00e7\u00e3o n\u00e3o trivial"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/","text":"ASM - Mapa de mem\u00f3ria \u00b6 A forma na qual a maioria das CPUs acessam perif\u00e9ricos (teclado/ mouse/ USB/ tela/ ...) \u00e9 a do perif\u00e9rico mapeado em mem\u00f3ria. Essa t\u00e9cnica utiliza da capacidade do computador de escrever e ler da mem\u00f3ria RAM, fazendo com que regi\u00f5es de endere\u00e7os da mem\u00f3ria n\u00e3o sejam uma 'mem\u00f3ria' f\u00edsica, mas sim um perif\u00e9rico do computador. Vamos trabalhar com o exemplo do nosso Z01, a mem\u00f3ria \u00e9 composta de: RAM LCD Chaves LEDs Nesse nosso hardware a mem\u00f3ria que \u00e9 vis\u00edvel pela CPU \u00e9 organizada da seguinte maneira: Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w 16384 - 21183 LCD w 21184 LED w 21185 SW r RAM \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w A mem\u00f3ria RAM \u00e9 um componente do computador que permite guardar dados vol\u00e1teis (que v\u00e3o se perder ap\u00f3s o reset do computador). \u00c9 nela que guardamos as vari\u00e1veis do programa. Note Nossa mem\u00f3ria RAM possui 16 bits de largura. A princ\u00edpio podemos utilizar qualquer endere\u00e7o da mem\u00f3ria RAM para armazenar dados tempor\u00e1rios, isso n\u00e3o ser\u00e1 verdade mais para frente do curso, onde iremos organizar nossa mem\u00f3ria RAM em sec\u00e7\u00f5es. Tip Iremos dar alguns nomes para os endere\u00e7os espec\u00edficos da mem\u00f3ria RAM: endere\u00e7o label / nome 0 SP 1 LCL 2 ARG 3 THIS 4 THAT Example Vamos fazer um exemplo que l\u00ea um dado na RAM[3] o incrementa e salva novamente no mesmo endere\u00e7o de mem\u00f3ria: c\u00f3digo simulador hardware leaw $ 3 , % A ; faz %A = 3 (%A aponta para RAM[3]) movw ( % A ), % D ; move o valor de RAM[%A] para %D incw % D ; incrementa o valor de D (D = D + 1, D = RAM[3] + 1) movw % D , ( % A ) ; move o valor incrementado de volta para a RAM[3] Podemos tamb\u00e9m usar o label ARG para referencia o endere\u00e7o 3 da mem\u00f3ria RAM: leaw $ ARG , % A ; faz %A = 3 (%A aponta para RAM[ARG]) Tip Execute voc\u00ea esse c\u00f3digo no simulador! E analise o resultado. Warning \u00c9 necess\u00e1rio notar que a mem\u00f3ria RAM n\u00e3o \u00e9 um registrador e possui uma grande limita\u00e7\u00e3o , n\u00e3o podemos realizar uma a\u00e7\u00e3o de ESCRITA E LEITURA no mesmo ciclo! O que impossibilita de fazermos o seguinte: leaw $ 3 , % A incw ( % A ) ; N\u00e3o funciona no nosso hardware!! addw ( % A ), % D , ( % A ) ; Nao funciona no nosso hardware!! O assembly permite que voc\u00eas escrevam essas opera\u00e7\u00f5es, por\u00e9m quando forem executar no hardware o resultado n\u00e3o vai ser o esperado. LEDs \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21184 LED w Os LEDs da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21184 onde cada bit (9..0) representa um LED, se o bit espec\u00edfico estiver valor 1 o LED est\u00e1 aceso e 0 apagado. Example Como isso \u00e9 traduzido para c\u00f3digo? Imagine que desejamos acender um LED que nosso computador controla, para isso devemos fazer com que o registrador %A aponte para o endere\u00e7o de mem\u00f3ria na qual o LED est\u00e1 associado e ent\u00e3o escreva nele: c\u00f3digo simulador leaw $ 21184 , % A ; endere\u00e7o do LED movw $ 1 , ( % A ) ; move valor 1 para ele Tip Execute voc\u00ea esse c\u00f3digo no simulador! Tip Note que usamos movw $1, (%A) . Isso \u00e9 poss\u00edvel porque nossa ULA \u00e9 capaz de gerar os valores 1 , -1 e 0 , mas outros valores n\u00e3o! SW \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21185 SW r Os chaves (SW) da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21185 onde cada bit (9..0) representa uma chave, se o bit espec\u00edfico estiver valor 1 indica que a chave est\u00e1 ligada (on) e 0 desligada. Example O exemplo a seguir copia o valor das chaves para os LEDs: c\u00f3digo simulador leaw $ 21185 , % A ; endere\u00e7o da chave movw ( % A ), % D ; copia valor das chaves para %D leaw $ 21184 , % A ; endere\u00e7o do LED movw % D , ( % A ) ; move valor das chaves para %D Tip Execute voc\u00ea esse c\u00f3digo no simulador! LCD \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 16384 - 21183 LCD w O nosso LCD \u00e9 um dispositivo de 320x240 pixels. Cada linha do endere\u00e7o de mem\u00f3ria do LCD representa 16 pixels do dispositivo, conforme figura anterior. Para acender um pixel, basta colocar 1 ou 0 para apagar.- endere\u00e7os do LCD Como nosso LCD possui 320px na horizontal, e como cada endere\u00e7o de mem\u00f3ria acessa 16px por vez, uma linha \u00e9 acess\u00edvel por: 320/16 = 20 endere\u00e7os. Ou seja, para acessar os primeiros px de cada linha devemos escrever endere\u00e7o de mem\u00f3ria: Primeira linha: 16384 + 0 vezes 20 : 16384 Segunda linha: 16384 + 1 vezes 20 : 16404 Terceira linha: 16384 + 2 vezes 20 : 16424 ... \u00daltima linha: 16384 + 239 vezes 20 : 21164 LCD Para desenhar um pixel no meio do LCD \u00e9 necess\u00e1rio carregar o valor 0x0001 no endere\u00e7o 18242 leaw $ 18242 , % A movw $ 1 , ( % A ) Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"ASM - Mapa de mem\u00f3ria"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/#asm-mapa-de-memoria","text":"A forma na qual a maioria das CPUs acessam perif\u00e9ricos (teclado/ mouse/ USB/ tela/ ...) \u00e9 a do perif\u00e9rico mapeado em mem\u00f3ria. Essa t\u00e9cnica utiliza da capacidade do computador de escrever e ler da mem\u00f3ria RAM, fazendo com que regi\u00f5es de endere\u00e7os da mem\u00f3ria n\u00e3o sejam uma 'mem\u00f3ria' f\u00edsica, mas sim um perif\u00e9rico do computador. Vamos trabalhar com o exemplo do nosso Z01, a mem\u00f3ria \u00e9 composta de: RAM LCD Chaves LEDs Nesse nosso hardware a mem\u00f3ria que \u00e9 vis\u00edvel pela CPU \u00e9 organizada da seguinte maneira: Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w 16384 - 21183 LCD w 21184 LED w 21185 SW r","title":"ASM - Mapa de mem\u00f3ria"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/#ram","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w A mem\u00f3ria RAM \u00e9 um componente do computador que permite guardar dados vol\u00e1teis (que v\u00e3o se perder ap\u00f3s o reset do computador). \u00c9 nela que guardamos as vari\u00e1veis do programa. Note Nossa mem\u00f3ria RAM possui 16 bits de largura. A princ\u00edpio podemos utilizar qualquer endere\u00e7o da mem\u00f3ria RAM para armazenar dados tempor\u00e1rios, isso n\u00e3o ser\u00e1 verdade mais para frente do curso, onde iremos organizar nossa mem\u00f3ria RAM em sec\u00e7\u00f5es. Tip Iremos dar alguns nomes para os endere\u00e7os espec\u00edficos da mem\u00f3ria RAM: endere\u00e7o label / nome 0 SP 1 LCL 2 ARG 3 THIS 4 THAT Example Vamos fazer um exemplo que l\u00ea um dado na RAM[3] o incrementa e salva novamente no mesmo endere\u00e7o de mem\u00f3ria: c\u00f3digo simulador hardware leaw $ 3 , % A ; faz %A = 3 (%A aponta para RAM[3]) movw ( % A ), % D ; move o valor de RAM[%A] para %D incw % D ; incrementa o valor de D (D = D + 1, D = RAM[3] + 1) movw % D , ( % A ) ; move o valor incrementado de volta para a RAM[3] Podemos tamb\u00e9m usar o label ARG para referencia o endere\u00e7o 3 da mem\u00f3ria RAM: leaw $ ARG , % A ; faz %A = 3 (%A aponta para RAM[ARG]) Tip Execute voc\u00ea esse c\u00f3digo no simulador! E analise o resultado. Warning \u00c9 necess\u00e1rio notar que a mem\u00f3ria RAM n\u00e3o \u00e9 um registrador e possui uma grande limita\u00e7\u00e3o , n\u00e3o podemos realizar uma a\u00e7\u00e3o de ESCRITA E LEITURA no mesmo ciclo! O que impossibilita de fazermos o seguinte: leaw $ 3 , % A incw ( % A ) ; N\u00e3o funciona no nosso hardware!! addw ( % A ), % D , ( % A ) ; Nao funciona no nosso hardware!! O assembly permite que voc\u00eas escrevam essas opera\u00e7\u00f5es, por\u00e9m quando forem executar no hardware o resultado n\u00e3o vai ser o esperado.","title":"RAM"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/#leds","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21184 LED w Os LEDs da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21184 onde cada bit (9..0) representa um LED, se o bit espec\u00edfico estiver valor 1 o LED est\u00e1 aceso e 0 apagado. Example Como isso \u00e9 traduzido para c\u00f3digo? Imagine que desejamos acender um LED que nosso computador controla, para isso devemos fazer com que o registrador %A aponte para o endere\u00e7o de mem\u00f3ria na qual o LED est\u00e1 associado e ent\u00e3o escreva nele: c\u00f3digo simulador leaw $ 21184 , % A ; endere\u00e7o do LED movw $ 1 , ( % A ) ; move valor 1 para ele Tip Execute voc\u00ea esse c\u00f3digo no simulador! Tip Note que usamos movw $1, (%A) . Isso \u00e9 poss\u00edvel porque nossa ULA \u00e9 capaz de gerar os valores 1 , -1 e 0 , mas outros valores n\u00e3o!","title":"LEDs"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/#sw","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21185 SW r Os chaves (SW) da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21185 onde cada bit (9..0) representa uma chave, se o bit espec\u00edfico estiver valor 1 indica que a chave est\u00e1 ligada (on) e 0 desligada. Example O exemplo a seguir copia o valor das chaves para os LEDs: c\u00f3digo simulador leaw $ 21185 , % A ; endere\u00e7o da chave movw ( % A ), % D ; copia valor das chaves para %D leaw $ 21184 , % A ; endere\u00e7o do LED movw % D , ( % A ) ; move valor das chaves para %D Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"SW"},{"location":"commum-content/teoria/Teoria-Z01-mapadeMemoria/#lcd","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 16384 - 21183 LCD w O nosso LCD \u00e9 um dispositivo de 320x240 pixels. Cada linha do endere\u00e7o de mem\u00f3ria do LCD representa 16 pixels do dispositivo, conforme figura anterior. Para acender um pixel, basta colocar 1 ou 0 para apagar.- endere\u00e7os do LCD Como nosso LCD possui 320px na horizontal, e como cada endere\u00e7o de mem\u00f3ria acessa 16px por vez, uma linha \u00e9 acess\u00edvel por: 320/16 = 20 endere\u00e7os. Ou seja, para acessar os primeiros px de cada linha devemos escrever endere\u00e7o de mem\u00f3ria: Primeira linha: 16384 + 0 vezes 20 : 16384 Segunda linha: 16384 + 1 vezes 20 : 16404 Terceira linha: 16384 + 2 vezes 20 : 16424 ... \u00daltima linha: 16384 + 239 vezes 20 : 21164 LCD Para desenhar um pixel no meio do LCD \u00e9 necess\u00e1rio carregar o valor 0x0001 no endere\u00e7o 18242 leaw $ 18242 , % A movw $ 1 , ( % A ) Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"LCD"},{"location":"commum-content/teoria/Teoria-Z01/","text":"Z01 \u00b6 Nosso computador ao final das entregas de hardware (mais uma \u00fanica entrega!) possuir\u00e1 a estrutura a seguir: No centro, a unidade central de processamento - CPU (Central processing unit) que \u00e9 respons\u00e1vel por realizar todas as opera\u00e7\u00f5es do computador (processamento, mover dados, decis\u00f5es, ...). A mem\u00f3ria ROM \u00e9 onde o programa a ser executado pela CPU est\u00e1 armazenado. A mem\u00f3ria RAM \u00e9 onde a CPU pode armazenar dados e tamb\u00e9m \u00e9 na RAM que temos os perif\u00e9rico do computador mapeado em mem\u00f3ria. Notem que a CPU \u00e9 respons\u00e1vel por gerar os sinais de controle tanto da ROM quanto da mem\u00f3ria RAM. Um dos sinais que a CPU gera \u00e9 chamado de Program Counter - PC , esse sinal \u00e9 conectado ao address da mem\u00f3ria ROM: O PC indica qual instru\u00e7\u00e3o a CPU ir\u00e1 buscar ( fetch ) na mem\u00f3ria para poder executar, o PC \u00e9 normalmente sequ\u00eancia se o c\u00f3digo n\u00e3o possui nenhuma condi\u00e7\u00e3o, a condi\u00e7\u00e3o faz com que o PC mude o valor atual dele para um novo valor, mas no pr\u00f3ximo clock continua a contagem a partir desse valor. A CPU acessa a mem\u00f3ria RAM com 4 sinais: addressM : Indica qual endere\u00e7o da mem\u00f3ria RAM a CPU est\u00e1 acessando outM : A informa\u00e7\u00e3o que a CPU deseja 'escrever' na RAM writeM : Se a CPU quer escrever ( writeM=1 ) ou ler ( writeM=0 ) da RAM inM : Caso a CPU leia da mem\u00f3ria RAM, a informa\u00e7\u00e3o \u00e9 transmitida por esse sinal! CPU \u00b6 A nossa CPU (proposta originalmente no livro texto), possui internamente dois registradores %A e %D de *16*bits cada, uma ULA, um Program Counter e um Control Unit :","title":"Z01"},{"location":"commum-content/teoria/Teoria-Z01/#z01","text":"Nosso computador ao final das entregas de hardware (mais uma \u00fanica entrega!) possuir\u00e1 a estrutura a seguir: No centro, a unidade central de processamento - CPU (Central processing unit) que \u00e9 respons\u00e1vel por realizar todas as opera\u00e7\u00f5es do computador (processamento, mover dados, decis\u00f5es, ...). A mem\u00f3ria ROM \u00e9 onde o programa a ser executado pela CPU est\u00e1 armazenado. A mem\u00f3ria RAM \u00e9 onde a CPU pode armazenar dados e tamb\u00e9m \u00e9 na RAM que temos os perif\u00e9rico do computador mapeado em mem\u00f3ria. Notem que a CPU \u00e9 respons\u00e1vel por gerar os sinais de controle tanto da ROM quanto da mem\u00f3ria RAM. Um dos sinais que a CPU gera \u00e9 chamado de Program Counter - PC , esse sinal \u00e9 conectado ao address da mem\u00f3ria ROM: O PC indica qual instru\u00e7\u00e3o a CPU ir\u00e1 buscar ( fetch ) na mem\u00f3ria para poder executar, o PC \u00e9 normalmente sequ\u00eancia se o c\u00f3digo n\u00e3o possui nenhuma condi\u00e7\u00e3o, a condi\u00e7\u00e3o faz com que o PC mude o valor atual dele para um novo valor, mas no pr\u00f3ximo clock continua a contagem a partir desse valor. A CPU acessa a mem\u00f3ria RAM com 4 sinais: addressM : Indica qual endere\u00e7o da mem\u00f3ria RAM a CPU est\u00e1 acessando outM : A informa\u00e7\u00e3o que a CPU deseja 'escrever' na RAM writeM : Se a CPU quer escrever ( writeM=1 ) ou ler ( writeM=0 ) da RAM inM : Caso a CPU leia da mem\u00f3ria RAM, a informa\u00e7\u00e3o \u00e9 transmitida por esse sinal!","title":"Z01"},{"location":"commum-content/teoria/Teoria-Z01/#cpu","text":"A nossa CPU (proposta originalmente no livro texto), possui internamente dois registradores %A e %D de *16*bits cada, uma ULA, um Program Counter e um Control Unit :","title":"CPU"},{"location":"commum-content/teoria/Teoria-memoria/","text":"","title":"Teoria memoria"},{"location":"commum-content/teoria/Teoria-multimidia/","text":"V\u00eddeos \u00b6 \u00c1lgebra Booleana \u00b6 Exerc\u00edcios \u00b6 v\u00eddeos \u00b6 Quiz \u00b6 L\u00f3gica booleana - Tabela Verdade Responda sobre tabela verdade \u00c9 correto afirmar sobre a tabela verdade: (pode existir mais de um item correto) Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? \ufeffQual tabela verdade a seguir foi montada correta? Considerando a equa\u00e7\u00e3o: X = not(B) + A , e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 \ufeffL\u00f3gica booleana 1 Quest\u00f5es b\u00e1sicas O que \u00e9 correto afirmar sobre bits? 1 AND 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: 1 OR 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1:","title":"V\u00eddeos"},{"location":"commum-content/teoria/Teoria-multimidia/#videos","text":"","title":"V\u00eddeos"},{"location":"commum-content/teoria/Teoria-multimidia/#algebra-booleana","text":"","title":"\u00c1lgebra Booleana"},{"location":"commum-content/teoria/Teoria-multimidia/#exercicios","text":"","title":"Exerc\u00edcios"},{"location":"commum-content/teoria/Teoria-multimidia/#videos_1","text":"","title":"v\u00eddeos"},{"location":"commum-content/teoria/Teoria-multimidia/#quiz","text":"","title":"Quiz"},{"location":"commum-content/teoria/Teoria-nasm-jump/","text":"ASM - jump \u00b6 Saltos (jumps) s\u00e3o instru\u00e7\u00f5es em assembly que permitem a execu\u00e7\u00e3o n\u00e3o sequ\u00eancial de um programa. As instru\u00e7\u00f5es de jumpo quando executadas alteram o program counter. Nossa CPU \u00e9 capaz de realizar c\u00f3digos com condi\u00e7\u00e3o, tal como: if a > 0 : b = 2 else : b = 3 ou: while True : b = b + 1 A maneira de realizarmos esse tipo de condi\u00e7\u00e3o \u00e9 com instru\u00e7\u00f5es de salto ( jump ), uma instru\u00e7\u00e3o de salto verifica uma determinada condi\u00e7\u00e3o e realiza ou n\u00e3o o salto com base nessa condi\u00e7\u00e3o, alterando o PC. A sequ\u00eancia de execu\u00e7\u00e3o do c\u00f3digo \u00e9 ditada pelo Program Counter (PC), um salto acontece quando o PC sofre uma mudan\u00e7a da sua sequ\u00eancia natural: | salto v PC: 0 1 2 3 4 8 9 10 11 --------------------------------> tempo Essa mudan\u00e7a pode ser tanto para 'frente' quanto para tr\u00e1s: | salto v PC: 0 1 2 3 4 0 1 2 3 4 x --------------------------------> tempo Salto O salto \u00e9 uma interrup\u00e7\u00e3o no fluxo cont\u00ednuo e sequencial de um programa. O salto pode ser condicional (if, ...) ou incondicional (salta sem condi\u00e7\u00e3o). PC \u00b6 Para executarmos um salto \u00e9 necess\u00e1rio alterarmos o valor do PC, no Z01 isso \u00e9 feito utilizando o valor que est\u00e1 salvo no registrador %A . No nosso caso, antes de realizarmos um salto \u00e9 necess\u00e1rio carregarmos em %A o endere\u00e7o da qual desejamos ir caso o salto se realize (condi\u00e7\u00e3o). O exemplo a seguir realiza um loop infinito (e n\u00e3o faz nada), ele trava nesse loop: c\u00f3digo simulador 0: leaw $ 0 , % A ; carrega 0 em %A (linha 0) 1: jmp ; faz o salto incondicional 2: nop ; nop O PC desse c\u00f3digo fica: | | | | v v v v 0 1 2 0 1 2 0 1 2 0 1 2 Note que o PC \u00e9 incrementado para o valor 2 mesmo ap\u00f3s a realiza\u00e7\u00e3o do salto ( jmp ), isso ocorre por um atraso no processamento do salto, \u00e9 por esse motivo que um salto (de qualquer tipo) deve ser sempre acompanhado de uma instru\u00e7\u00e3o do tipo nop , o nop \u00e9 uma instru\u00e7\u00e3o que n\u00e3o realizada nada na CPU, ela \u00e9 usada para 'dar' tempo a CPU executar o salto. jmp \u00e9 o comando em assembly de salto incondicional. Note Repare que realizamos o comando leaw $0, %A antes de realizarmos o salto, isso \u00e9 necess\u00e1rio pois o valor carregado em PC \u00e9 o valor de %A . nop \u00b6 No exemplo anterior logo ap\u00f3s o salto jmp aparece a instru\u00e7\u00e3o nop . O No Operation ( nop ) \u00e9 uma instru\u00e7\u00e3o que n\u00e3o faz nada na CPU, n\u00e3o modifica registradores e n\u00e3o modifica mem\u00f3ria. Ela serve para 'dar' tempo a CPU para realizar o salto. Como o salto \u00e9 algo que quebra o fluxo cont\u00ednuo de execu\u00e7\u00e3o do c\u00f3digo (chamamos isso de pipeline), \u00e9 necess\u00e1rio colocarmos essa instru\u00e7\u00e3o para que a CPU se organize internamente para realizar a nova sequ\u00eancia de instru\u00e7\u00f5es. Imaginem que um modelo de carros espec\u00edfico est\u00e1 sendo fabricado em uma linha de produ\u00e7\u00e3o, toda a linha (pipeline) est\u00e1 preparada para montar esse tipo de carro (ferramentas, desenhos t\u00e9cnicos, ...) e a fabrica decide por fabricar um carro de modelo diferente (quebra no pipeline). Duas s\u00e3o as alternativas: desligar toda a linha de produ\u00e7\u00e3o para o pessoal se adequar ou deixar a linha em andamento, mas n\u00e3o colocar nenhum carro nela e dar tempo das pessoas se adequarem. A op\u00e7\u00e3o de desligar a linha \u00e9 uma analogia a 'desligarmos' o clock de parte da CPU, que \u00e9 algo mais complexo. A segunda op\u00e7\u00e3o \u00e9 a de colocar opera\u00e7\u00f5es que n\u00e3o fazem nada na CPU dando assim tempo de ajuste interno ( nop ). Salto incondicional \u00b6 O salto mais simples que podemos realizar \u00e9 o salto sem condi\u00e7\u00f5es. Ou seja, chegou nessa instru\u00e7\u00e3o, salta. Isso \u00e9 muito utilizado para realizarmos while(True) , possuimos apenas uma instru\u00e7\u00e3o que realiza o salto incodicional: jmp Warning Antes de realizarmos qualquer salto \u00e9 necess\u00e1rio carregarmos em %A o destino para onde desejamos ir. label \u00b6 Para facilitar o uso de saltos, podemos criar labels no nosso c\u00f3digo assembly, o label \u00e9 um nome que damos para a linha que desejamos saltar. Label e uma string seguida de : : LABEL: O c\u00f3digo anterior ficaria o seguinte com uso de label: c\u00f3digo simulador LOOP: ; label LOOP leaw $ LOOP , % A ; Aqui, $LOOP seria substituido por 0 pelo montador jmp nop Note O label n\u00e3o \u00e9 uma instru\u00e7\u00e3o, \u00e9 um nome para a linha em quest\u00e3o e portanto n\u00e3o \u00e9 convertido para nenhuma opera\u00e7\u00e3o de hardware. Tip Teste o c\u00f3digo anterior no Z01-Simulator . Salto condicional \u00b6 O salto condicional \u00e9 aquele que \u00e9 utilizado para realizarmos if ... else , nele um salto s\u00f3 \u00e9 executado caso uma condi\u00e7\u00e3o espec\u00edfica seja satisfeita. Nossa CPU \u00e9 capaz de realizar a seguintes condi\u00e7\u00f5es: je %D : Salta se valor de %D \u00e9 igual a 0 jne %D : Salta se valor de %D for diferente de 0 jg %D : Salta se valor de %D for maior que 0 jl %D : Salta se valor de %D for menor que 0 jge %D : Salta se valor de %D for maior ou igual a 0 jle %D : Salta se valor de %D for menor ou igual a 0 %D indica o valor salvo no registrador D. Example considere o pseudo c\u00f3digo a seguir: if RAM [ 1 ] > 0 : RAM [ 2 ] = 1 else : RAM [ 2 ] = 2 nasm simulador Em assembly do Z01: leaw $ 1 , % A ; faz %A apontar para RAM[1] movw ( % A ), % D ; carrega o valor de RAM[1] em %D leaw $ ELSE , % A ; precisamos carregar em %A o valor do salto jle % D ; salta se valor em %D for menor ou igual a zero nop ; ; if leaw $ 2 , % A ; movw $ 1 , ( % A ) ; ; leaw $ END , % A ; agora n\u00e3o podemos executar o trecho jmp ; do else, vamos pular para o fim nop ; do c\u00f3digo ; ELSE: ; else ; leaw $ 2 , % A ; movw % A , ( % A ) ; ; END: ; RAM[1] = 0 Warning As labels precisam estar escritas da mesma maneira, altere ea linha 9 para leaw $end, $A ou a linha 15 para END: Tip Teste o c\u00f3digo anterior no Z01-Simulator . Hardware \u00b6 O salto condicional utiliza o comparador que est\u00e1 dentro da nossa ULA para verificar a condi\u00e7\u00e3o e realizar o salto, as etapas s\u00e3o: O Control Unit faz com que o valor do registrador %D passe pela ULA Quando %D sai pela ULA o Comparador gera os sinais ng : menor que zero zr : igual a zero Esses sinais v\u00e3o at\u00e9 o Control Unit O control Unit verifica a condi\u00e7\u00e3o do salto e os valores de ng e zr , se forem condizentes, faz load_PC <= '1' caso contr\u00e1rio, n\u00e3o salta load_pc <= '0' .","title":"ASM - jump"},{"location":"commum-content/teoria/Teoria-nasm-jump/#asm-jump","text":"Saltos (jumps) s\u00e3o instru\u00e7\u00f5es em assembly que permitem a execu\u00e7\u00e3o n\u00e3o sequ\u00eancial de um programa. As instru\u00e7\u00f5es de jumpo quando executadas alteram o program counter. Nossa CPU \u00e9 capaz de realizar c\u00f3digos com condi\u00e7\u00e3o, tal como: if a > 0 : b = 2 else : b = 3 ou: while True : b = b + 1 A maneira de realizarmos esse tipo de condi\u00e7\u00e3o \u00e9 com instru\u00e7\u00f5es de salto ( jump ), uma instru\u00e7\u00e3o de salto verifica uma determinada condi\u00e7\u00e3o e realiza ou n\u00e3o o salto com base nessa condi\u00e7\u00e3o, alterando o PC. A sequ\u00eancia de execu\u00e7\u00e3o do c\u00f3digo \u00e9 ditada pelo Program Counter (PC), um salto acontece quando o PC sofre uma mudan\u00e7a da sua sequ\u00eancia natural: | salto v PC: 0 1 2 3 4 8 9 10 11 --------------------------------> tempo Essa mudan\u00e7a pode ser tanto para 'frente' quanto para tr\u00e1s: | salto v PC: 0 1 2 3 4 0 1 2 3 4 x --------------------------------> tempo Salto O salto \u00e9 uma interrup\u00e7\u00e3o no fluxo cont\u00ednuo e sequencial de um programa. O salto pode ser condicional (if, ...) ou incondicional (salta sem condi\u00e7\u00e3o).","title":"ASM - jump"},{"location":"commum-content/teoria/Teoria-nasm-jump/#pc","text":"Para executarmos um salto \u00e9 necess\u00e1rio alterarmos o valor do PC, no Z01 isso \u00e9 feito utilizando o valor que est\u00e1 salvo no registrador %A . No nosso caso, antes de realizarmos um salto \u00e9 necess\u00e1rio carregarmos em %A o endere\u00e7o da qual desejamos ir caso o salto se realize (condi\u00e7\u00e3o). O exemplo a seguir realiza um loop infinito (e n\u00e3o faz nada), ele trava nesse loop: c\u00f3digo simulador 0: leaw $ 0 , % A ; carrega 0 em %A (linha 0) 1: jmp ; faz o salto incondicional 2: nop ; nop O PC desse c\u00f3digo fica: | | | | v v v v 0 1 2 0 1 2 0 1 2 0 1 2 Note que o PC \u00e9 incrementado para o valor 2 mesmo ap\u00f3s a realiza\u00e7\u00e3o do salto ( jmp ), isso ocorre por um atraso no processamento do salto, \u00e9 por esse motivo que um salto (de qualquer tipo) deve ser sempre acompanhado de uma instru\u00e7\u00e3o do tipo nop , o nop \u00e9 uma instru\u00e7\u00e3o que n\u00e3o realizada nada na CPU, ela \u00e9 usada para 'dar' tempo a CPU executar o salto. jmp \u00e9 o comando em assembly de salto incondicional. Note Repare que realizamos o comando leaw $0, %A antes de realizarmos o salto, isso \u00e9 necess\u00e1rio pois o valor carregado em PC \u00e9 o valor de %A .","title":"PC"},{"location":"commum-content/teoria/Teoria-nasm-jump/#nop","text":"No exemplo anterior logo ap\u00f3s o salto jmp aparece a instru\u00e7\u00e3o nop . O No Operation ( nop ) \u00e9 uma instru\u00e7\u00e3o que n\u00e3o faz nada na CPU, n\u00e3o modifica registradores e n\u00e3o modifica mem\u00f3ria. Ela serve para 'dar' tempo a CPU para realizar o salto. Como o salto \u00e9 algo que quebra o fluxo cont\u00ednuo de execu\u00e7\u00e3o do c\u00f3digo (chamamos isso de pipeline), \u00e9 necess\u00e1rio colocarmos essa instru\u00e7\u00e3o para que a CPU se organize internamente para realizar a nova sequ\u00eancia de instru\u00e7\u00f5es. Imaginem que um modelo de carros espec\u00edfico est\u00e1 sendo fabricado em uma linha de produ\u00e7\u00e3o, toda a linha (pipeline) est\u00e1 preparada para montar esse tipo de carro (ferramentas, desenhos t\u00e9cnicos, ...) e a fabrica decide por fabricar um carro de modelo diferente (quebra no pipeline). Duas s\u00e3o as alternativas: desligar toda a linha de produ\u00e7\u00e3o para o pessoal se adequar ou deixar a linha em andamento, mas n\u00e3o colocar nenhum carro nela e dar tempo das pessoas se adequarem. A op\u00e7\u00e3o de desligar a linha \u00e9 uma analogia a 'desligarmos' o clock de parte da CPU, que \u00e9 algo mais complexo. A segunda op\u00e7\u00e3o \u00e9 a de colocar opera\u00e7\u00f5es que n\u00e3o fazem nada na CPU dando assim tempo de ajuste interno ( nop ).","title":"nop"},{"location":"commum-content/teoria/Teoria-nasm-jump/#salto-incondicional","text":"O salto mais simples que podemos realizar \u00e9 o salto sem condi\u00e7\u00f5es. Ou seja, chegou nessa instru\u00e7\u00e3o, salta. Isso \u00e9 muito utilizado para realizarmos while(True) , possuimos apenas uma instru\u00e7\u00e3o que realiza o salto incodicional: jmp Warning Antes de realizarmos qualquer salto \u00e9 necess\u00e1rio carregarmos em %A o destino para onde desejamos ir.","title":"Salto incondicional"},{"location":"commum-content/teoria/Teoria-nasm-jump/#label","text":"Para facilitar o uso de saltos, podemos criar labels no nosso c\u00f3digo assembly, o label \u00e9 um nome que damos para a linha que desejamos saltar. Label e uma string seguida de : : LABEL: O c\u00f3digo anterior ficaria o seguinte com uso de label: c\u00f3digo simulador LOOP: ; label LOOP leaw $ LOOP , % A ; Aqui, $LOOP seria substituido por 0 pelo montador jmp nop Note O label n\u00e3o \u00e9 uma instru\u00e7\u00e3o, \u00e9 um nome para a linha em quest\u00e3o e portanto n\u00e3o \u00e9 convertido para nenhuma opera\u00e7\u00e3o de hardware. Tip Teste o c\u00f3digo anterior no Z01-Simulator .","title":"label"},{"location":"commum-content/teoria/Teoria-nasm-jump/#salto-condicional","text":"O salto condicional \u00e9 aquele que \u00e9 utilizado para realizarmos if ... else , nele um salto s\u00f3 \u00e9 executado caso uma condi\u00e7\u00e3o espec\u00edfica seja satisfeita. Nossa CPU \u00e9 capaz de realizar a seguintes condi\u00e7\u00f5es: je %D : Salta se valor de %D \u00e9 igual a 0 jne %D : Salta se valor de %D for diferente de 0 jg %D : Salta se valor de %D for maior que 0 jl %D : Salta se valor de %D for menor que 0 jge %D : Salta se valor de %D for maior ou igual a 0 jle %D : Salta se valor de %D for menor ou igual a 0 %D indica o valor salvo no registrador D. Example considere o pseudo c\u00f3digo a seguir: if RAM [ 1 ] > 0 : RAM [ 2 ] = 1 else : RAM [ 2 ] = 2 nasm simulador Em assembly do Z01: leaw $ 1 , % A ; faz %A apontar para RAM[1] movw ( % A ), % D ; carrega o valor de RAM[1] em %D leaw $ ELSE , % A ; precisamos carregar em %A o valor do salto jle % D ; salta se valor em %D for menor ou igual a zero nop ; ; if leaw $ 2 , % A ; movw $ 1 , ( % A ) ; ; leaw $ END , % A ; agora n\u00e3o podemos executar o trecho jmp ; do else, vamos pular para o fim nop ; do c\u00f3digo ; ELSE: ; else ; leaw $ 2 , % A ; movw % A , ( % A ) ; ; END: ; RAM[1] = 0 Warning As labels precisam estar escritas da mesma maneira, altere ea linha 9 para leaw $end, $A ou a linha 15 para END: Tip Teste o c\u00f3digo anterior no Z01-Simulator .","title":"Salto condicional"},{"location":"commum-content/teoria/Teoria-nasm-jump/#hardware","text":"O salto condicional utiliza o comparador que est\u00e1 dentro da nossa ULA para verificar a condi\u00e7\u00e3o e realizar o salto, as etapas s\u00e3o: O Control Unit faz com que o valor do registrador %D passe pela ULA Quando %D sai pela ULA o Comparador gera os sinais ng : menor que zero zr : igual a zero Esses sinais v\u00e3o at\u00e9 o Control Unit O control Unit verifica a condi\u00e7\u00e3o do salto e os valores de ng e zr , se forem condizentes, faz load_PC <= '1' caso contr\u00e1rio, n\u00e3o salta load_pc <= '0' .","title":"Hardware"},{"location":"commum-content/teoria/Teoria-vm-funcoes/","text":"VM - Fun\u00e7\u00f5es \u00b6 Video A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Na pasta do projeto H-VM/src/vmExamples/SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es: O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre deve existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em Python para VM: def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em VM: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos. return \u00b6 A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico valor apenas. Chamada de fun\u00e7\u00e3o \u00b6 A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 como argumentos / par\u00e2metros da fun\u00e7\u00e3o. function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2 Graficamente \u00b6","title":"VM - Fun\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-vm-funcoes/#vm-funcoes","text":"Video A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Na pasta do projeto H-VM/src/vmExamples/SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es: O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre deve existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em Python para VM: def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em VM: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos.","title":"VM - Fun\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-vm-funcoes/#return","text":"A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico valor apenas.","title":"return"},{"location":"commum-content/teoria/Teoria-vm-funcoes/#chamada-de-funcao","text":"A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 como argumentos / par\u00e2metros da fun\u00e7\u00e3o. function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"commum-content/teoria/Teoria-vm-funcoes/#graficamente","text":"","title":"Graficamente"},{"location":"commum-content/teoria/Teoria-vm-jump/","text":"VM - jump \u00b6 Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push constant 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END labels \u00b6 Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"VM - jump"},{"location":"commum-content/teoria/Teoria-vm-jump/#vm-jump","text":"Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push constant 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END","title":"VM - jump"},{"location":"commum-content/teoria/Teoria-vm-jump/#labels","text":"Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"labels"},{"location":"commum-content/teoria/Teoria-vm-memoria/","text":"VM - Mem\u00f3ria \u00b6 Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que serviram para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es: Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem pap\u00e9is especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o essas : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela VM (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Vamos detalhar um pouco de cada item descrito nesse resumo. Stack \u00b6 A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influ\u00eancia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMTranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem Assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o. Stack Pointer \u00b6 \u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack Overflow Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 colocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada para o Heap, corrompendo os dados que estavam ali salvos). Fun\u00e7\u00f5es \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o), isto \u00e9 conhecido como salvar contexto (antes da execu\u00e7\u00e3o da fun\u00e7\u00e3o) e restaurar contexto (ap\u00f3s da execu\u00e7\u00e3o da fun\u00e7\u00e3o). Para isso \u00e9 salvo na pilha: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Veja como fica um exemplo em Java : void example ( int a , int b ){ int aux0 ; int aux1 ; aux0 = a ; aux1 = b ; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em Java anteriormente seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static: O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, incluimos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chamada da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"VM - Mem\u00f3ria"},{"location":"commum-content/teoria/Teoria-vm-memoria/#vm-memoria","text":"Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que serviram para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es: Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem pap\u00e9is especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o essas : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela VM (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Vamos detalhar um pouco de cada item descrito nesse resumo.","title":"VM - Mem\u00f3ria"},{"location":"commum-content/teoria/Teoria-vm-memoria/#stack","text":"A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influ\u00eancia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMTranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem Assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o.","title":"Stack"},{"location":"commum-content/teoria/Teoria-vm-memoria/#stack-pointer","text":"\u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack Overflow Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 colocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada para o Heap, corrompendo os dados que estavam ali salvos).","title":"Stack Pointer"},{"location":"commum-content/teoria/Teoria-vm-memoria/#funcoes","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o), isto \u00e9 conhecido como salvar contexto (antes da execu\u00e7\u00e3o da fun\u00e7\u00e3o) e restaurar contexto (ap\u00f3s da execu\u00e7\u00e3o da fun\u00e7\u00e3o). Para isso \u00e9 salvo na pilha: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-vm-memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Veja como fica um exemplo em Java : void example ( int a , int b ){ int aux0 ; int aux1 ; aux0 = a ; aux1 = b ; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em Java anteriormente seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"commum-content/teoria/Teoria-vm-memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n","title":"ARG - Argumento"},{"location":"commum-content/teoria/Teoria-vm-memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static: O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"commum-content/teoria/Teoria-vm-memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"commum-content/teoria/Teoria-vm-memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"commum-content/teoria/Teoria-vm-memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, incluimos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chamada da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"commum-content/teoria/Teoria-vm-segmentos/","text":"VM - Segmentos \u00b6 Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pilha (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM Exemplo, acessando o temp \u00b6 Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 Escrevendo um pixel no LCD \u00b6 Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"VM - Segmentos"},{"location":"commum-content/teoria/Teoria-vm-segmentos/#vm-segmentos","text":"Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pilha (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM","title":"VM - Segmentos"},{"location":"commum-content/teoria/Teoria-vm-segmentos/#exemplo-acessando-o-temp","text":"Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3","title":"Exemplo, acessando o temp"},{"location":"commum-content/teoria/Teoria-vm-segmentos/#escrevendo-um-pixel-no-lcd","text":"Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"Escrevendo um pixel no LCD"},{"location":"commum-content/teoria/Teoria-vm/","text":"VM \u00b6 Video A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o lidam mais com registradores do computador por\u00e9m com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual: Abstra\u00e7\u00e3o de Hardware (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) Portabilidade C\u00f3digo mais alto n\u00edvel (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Exemplo O programa a seguir escrito em vm, faz uso de uma fun\u00e7\u00e3o de multiplica\u00e7\u00e3o para multiplicar 7*2: function Main.main 0 push constant 7 push constant 2 call mult 2 A fun\u00e7\u00e3o de multiplica\u00e7\u00e3o mult \u00e9 implementada como a seguir: function mult 2 push constant 0 pop local 0 push argument 1 pop local 1 label loop push constant 0 push local 1 eq if-goto end push local 0 push argument 0 add pop local 0 push local 1 push constant 1 sub pop local 1 goto loop label end push local 0 return Tip Temos muitos outros exemplos na pasta: H-VM/src/examples/ Pilha \u00b6 Video A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra o c\u00f3digo a evolu\u00e7\u00e3o da pilha quando o c\u00f3digo a seguir \u00e9 executado: push constant 3 push constant 7 add pop temp 0 Esse c\u00f3digo carrega as constantes 3 e 7 para a pilha e faz soma deles, o resultado \u00e9 guardado no endere\u00e7o de temp 0. !!! info \"Nota\u00e7\u00e0o Explicando A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 . Stack Pointer (SP) \u00b6 O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada. Opera\u00e7\u00f5es \u00b6 Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add \u00b6 executa: X + Y sub \u00b6 executa: X - Y neg \u00b6 executa: -Y (complemento de dois) eq \u00b6 compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt \u00b6 compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt \u00b6 compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and \u00b6 executa: X and Y (bit a bit) or \u00b6 executa: X or Y (bit a bit) not \u00b6 executa: not Y (bit a bit) Note As opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!)","title":"VM"},{"location":"commum-content/teoria/Teoria-vm/#vm","text":"Video A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o lidam mais com registradores do computador por\u00e9m com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual: Abstra\u00e7\u00e3o de Hardware (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) Portabilidade C\u00f3digo mais alto n\u00edvel (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Exemplo O programa a seguir escrito em vm, faz uso de uma fun\u00e7\u00e3o de multiplica\u00e7\u00e3o para multiplicar 7*2: function Main.main 0 push constant 7 push constant 2 call mult 2 A fun\u00e7\u00e3o de multiplica\u00e7\u00e3o mult \u00e9 implementada como a seguir: function mult 2 push constant 0 pop local 0 push argument 1 pop local 1 label loop push constant 0 push local 1 eq if-goto end push local 0 push argument 0 add pop local 0 push local 1 push constant 1 sub pop local 1 goto loop label end push local 0 return Tip Temos muitos outros exemplos na pasta: H-VM/src/examples/","title":"VM"},{"location":"commum-content/teoria/Teoria-vm/#pilha","text":"Video A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra o c\u00f3digo a evolu\u00e7\u00e3o da pilha quando o c\u00f3digo a seguir \u00e9 executado: push constant 3 push constant 7 add pop temp 0 Esse c\u00f3digo carrega as constantes 3 e 7 para a pilha e faz soma deles, o resultado \u00e9 guardado no endere\u00e7o de temp 0. !!! info \"Nota\u00e7\u00e0o Explicando A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 .","title":"Pilha"},{"location":"commum-content/teoria/Teoria-vm/#stack-pointer-sp","text":"O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada.","title":"Stack Pointer (SP)"},{"location":"commum-content/teoria/Teoria-vm/#operacoes","text":"Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha:","title":"Opera\u00e7\u00f5es"},{"location":"commum-content/teoria/Teoria-vm/#add","text":"executa: X + Y","title":"add"},{"location":"commum-content/teoria/Teoria-vm/#sub","text":"executa: X - Y","title":"sub"},{"location":"commum-content/teoria/Teoria-vm/#neg","text":"executa: -Y (complemento de dois)","title":"neg"},{"location":"commum-content/teoria/Teoria-vm/#eq","text":"compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"eq"},{"location":"commum-content/teoria/Teoria-vm/#gt","text":"compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"gt"},{"location":"commum-content/teoria/Teoria-vm/#lt","text":"compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"lt"},{"location":"commum-content/teoria/Teoria-vm/#and","text":"executa: X and Y (bit a bit)","title":"and"},{"location":"commum-content/teoria/Teoria-vm/#or","text":"executa: X or Y (bit a bit)","title":"or"},{"location":"commum-content/teoria/Teoria-vm/#not","text":"executa: not Y (bit a bit) Note As opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!)","title":"not"},{"location":"commum-content/util/Util-Aulas/","text":"Resumo Aulas \u00b6 Resumo e planejamento das aulas. 10/06 - Av4 - AF \u00b6 Aula 08/06 \u00b6 Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 18: VMTranslator (loops e fun\u00e7\u00f5es) Aula 03/06 \u00b6 Estudo pr\u00e9vio Exerc\u00edcios VM - Lab 17 Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 18: VMTranslator (writePushPop e writeArithmetic) Aula 01/06 \u00b6 Estudo pr\u00e9vio VM - jump VM - Fun\u00e7\u00f5es Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (goto (jump) e fun\u00e7\u00f5es) Aula 27/05 \u00b6 Estudo pr\u00e9vio VM - Segmentos VM - Mem\u00f3ria Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (Treinando RPN e VM Z01 - b\u00e1sico) Aula 25/05 \u00b6 Estudo pr\u00e9vio Linguagem de M\u00e1quina Virtual Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Aula 20/05 \u00b6 Estudo pr\u00e9vio Assembler - Tabela de s\u00edmbolos Resolu\u00e7\u00e3o prova (0h30) D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h00) Lab 16: Assembler - parte 4 Lab 16: Assembler - parte 5 18/05 - Av3 \u00b6 Aula 13/05 \u00b6 Estudo pr\u00e9vio Assembler Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 16: Assembler Aula 11/05 \u00b6 Estudo pr\u00e9vio Assembler Expositiva/D\u00favidas (1h20) Laborat\u00f3rio (0h40) Lab 16: Assembler Aula 06/05 \u00b6 Exerc\u00edcios - CPU/ D\u00favidas (1h00) Aula est\u00fadio (1h00) Aula 04/05 \u00b6 Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 15: Control unit Aula 29/04 \u00b6 Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 14: Pequena CPU Aula 27/04 \u00b6 Estudo pr\u00e9vio ASM - Jump Revis\u00e3o/ D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h30) Lab 12: Jump Lab 13: Praticando Aula 20/04 \u00b6 Estudo pr\u00e9vio ASM - Mapa de mem\u00f3ria Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 11: Perif\u00e9ricos Aula 13/04 \u00b6 Estudo pr\u00e9vio Linguagem de m\u00e1quina ASM - Assembly Resumo - Assembly Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 10: Assembly Aula 01/04 \u00b6 Segunda Avalia\u00e7\u00e3o Individual - Av2 Aula 30/03 \u00b6 Projeto D-L\u00f3gica Sequencial. Expositiva/ D\u00favidas (0h30) Aula est\u00fadio (1h30) Aula 25/03 \u00b6 Come\u00e7o do projeto D-L\u00f3gica Sequencial. Estudo pr\u00e9vio L\u00f3gica Sequencial Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 9: L\u00f3gica sequencial Aula 23/03 \u00b6 Detalhes da ULA da CPU do Z01.1. Estudo pr\u00e9vio ULA Expositiva/D\u00favidas (0h30) Laborat\u00f3rios (0h30) Lab 8: ULA Aula est\u00fadio (1h00) Aula 18/03 \u00b6 Come\u00e7o do projeto C-ULA, trabalhando com aritm\u00e9tica bin\u00e1ria. Estudo pr\u00e9vio Aritm\u00e9tica Bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW Expositiva/ D\u00favidas (0h30): Handout (0h40): Handout Aritm\u00e9tica Booleana Laborat\u00f3rios (0h50) Lab 6: Adders Lab 7: Visualizando simula\u00e7\u00e3o Aula 16/03 \u00b6 Projeto B - L\u00f3gica Combinacional Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab5: L\u00f3gica Combinacional Aula 11/03 \u00b6 Inicio do projeto B - L\u00f3gica Combinacional, come\u00e7o do uso de VHDL. Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h40) Laborat\u00f3rios (1h20) Lab4: FPGA - VHDL Aula 09/03 \u00b6 Primeira Avalia\u00e7\u00e3o Individual - Av1 Aula 04/03 \u00b6 Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI Lab 2: GitHub Lab 3: GitHub Aula 25/02 \u00b6 Trabalhar com transistores e circuitos integrados. Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI Aula 23/02 \u00b6 Estudar l\u00f3gica booleana e praticar Estudo pr\u00e9vio Teoria \u00c1lgebra Booleana Expositiva/ D\u00favidas (45 min) Handout/ Exerc\u00edcio/ Vevox (1h15): \u00c1lgebra Booleana - 1 \u00c1lgebra Booleana - 2 Aula 18/02 \u00b6 D\u00favidas sobre dados digitais, uma breve vis\u00e3o geral sobre git e github. Estudo pr\u00e9vio Dados digitais Expositiva/ D\u00favidas (0h40): Slides Handout/ Exerc\u00edcio (1h20): Dados Digitais 1 Dados Digitais 2 Aula 16/02 \u00b6 Aula de apresenta\u00e7\u00e3o da mat\u00e9ria; vis\u00e3o geral do que vai ser feito; cria\u00e7\u00e3o de grupos. Slides (1h00): Slide Prezi Handout/ Estudo/ Exerc\u00edcio (1h00): Montar grupos Mural","title":"Resumo Aulas"},{"location":"commum-content/util/Util-Aulas/#resumo-aulas","text":"Resumo e planejamento das aulas.","title":"Resumo Aulas"},{"location":"commum-content/util/Util-Aulas/#1006-av4-af","text":"","title":"10/06 - Av4 - AF"},{"location":"commum-content/util/Util-Aulas/#aula-0806","text":"Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 18: VMTranslator (loops e fun\u00e7\u00f5es)","title":"Aula 08/06"},{"location":"commum-content/util/Util-Aulas/#aula-0306","text":"Estudo pr\u00e9vio Exerc\u00edcios VM - Lab 17 Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 18: VMTranslator (writePushPop e writeArithmetic)","title":"Aula 03/06"},{"location":"commum-content/util/Util-Aulas/#aula-0106","text":"Estudo pr\u00e9vio VM - jump VM - Fun\u00e7\u00f5es Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (goto (jump) e fun\u00e7\u00f5es)","title":"Aula 01/06"},{"location":"commum-content/util/Util-Aulas/#aula-2705","text":"Estudo pr\u00e9vio VM - Segmentos VM - Mem\u00f3ria Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (Treinando RPN e VM Z01 - b\u00e1sico)","title":"Aula 27/05"},{"location":"commum-content/util/Util-Aulas/#aula-2505","text":"Estudo pr\u00e9vio Linguagem de M\u00e1quina Virtual Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00)","title":"Aula 25/05"},{"location":"commum-content/util/Util-Aulas/#aula-2005","text":"Estudo pr\u00e9vio Assembler - Tabela de s\u00edmbolos Resolu\u00e7\u00e3o prova (0h30) D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h00) Lab 16: Assembler - parte 4 Lab 16: Assembler - parte 5","title":"Aula 20/05"},{"location":"commum-content/util/Util-Aulas/#1805-av3","text":"","title":"18/05 - Av3"},{"location":"commum-content/util/Util-Aulas/#aula-1305","text":"Estudo pr\u00e9vio Assembler Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 16: Assembler","title":"Aula 13/05"},{"location":"commum-content/util/Util-Aulas/#aula-1105","text":"Estudo pr\u00e9vio Assembler Expositiva/D\u00favidas (1h20) Laborat\u00f3rio (0h40) Lab 16: Assembler","title":"Aula 11/05"},{"location":"commum-content/util/Util-Aulas/#aula-0605","text":"Exerc\u00edcios - CPU/ D\u00favidas (1h00) Aula est\u00fadio (1h00)","title":"Aula 06/05"},{"location":"commum-content/util/Util-Aulas/#aula-0405","text":"Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 15: Control unit","title":"Aula 04/05"},{"location":"commum-content/util/Util-Aulas/#aula-2904","text":"Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 14: Pequena CPU","title":"Aula 29/04"},{"location":"commum-content/util/Util-Aulas/#aula-2704","text":"Estudo pr\u00e9vio ASM - Jump Revis\u00e3o/ D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h30) Lab 12: Jump Lab 13: Praticando","title":"Aula 27/04"},{"location":"commum-content/util/Util-Aulas/#aula-2004","text":"Estudo pr\u00e9vio ASM - Mapa de mem\u00f3ria Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 11: Perif\u00e9ricos","title":"Aula 20/04"},{"location":"commum-content/util/Util-Aulas/#aula-1304","text":"Estudo pr\u00e9vio Linguagem de m\u00e1quina ASM - Assembly Resumo - Assembly Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 10: Assembly","title":"Aula 13/04"},{"location":"commum-content/util/Util-Aulas/#aula-0104","text":"Segunda Avalia\u00e7\u00e3o Individual - Av2","title":"Aula 01/04"},{"location":"commum-content/util/Util-Aulas/#aula-3003","text":"Projeto D-L\u00f3gica Sequencial. Expositiva/ D\u00favidas (0h30) Aula est\u00fadio (1h30)","title":"Aula 30/03"},{"location":"commum-content/util/Util-Aulas/#aula-2503","text":"Come\u00e7o do projeto D-L\u00f3gica Sequencial. Estudo pr\u00e9vio L\u00f3gica Sequencial Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 9: L\u00f3gica sequencial","title":"Aula 25/03"},{"location":"commum-content/util/Util-Aulas/#aula-2303","text":"Detalhes da ULA da CPU do Z01.1. Estudo pr\u00e9vio ULA Expositiva/D\u00favidas (0h30) Laborat\u00f3rios (0h30) Lab 8: ULA Aula est\u00fadio (1h00)","title":"Aula 23/03"},{"location":"commum-content/util/Util-Aulas/#aula-1803","text":"Come\u00e7o do projeto C-ULA, trabalhando com aritm\u00e9tica bin\u00e1ria. Estudo pr\u00e9vio Aritm\u00e9tica Bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW Expositiva/ D\u00favidas (0h30): Handout (0h40): Handout Aritm\u00e9tica Booleana Laborat\u00f3rios (0h50) Lab 6: Adders Lab 7: Visualizando simula\u00e7\u00e3o","title":"Aula 18/03"},{"location":"commum-content/util/Util-Aulas/#aula-1603","text":"Projeto B - L\u00f3gica Combinacional Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab5: L\u00f3gica Combinacional","title":"Aula 16/03"},{"location":"commum-content/util/Util-Aulas/#aula-1103","text":"Inicio do projeto B - L\u00f3gica Combinacional, come\u00e7o do uso de VHDL. Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h40) Laborat\u00f3rios (1h20) Lab4: FPGA - VHDL","title":"Aula 11/03"},{"location":"commum-content/util/Util-Aulas/#aula-0903","text":"Primeira Avalia\u00e7\u00e3o Individual - Av1","title":"Aula 09/03"},{"location":"commum-content/util/Util-Aulas/#aula-0403","text":"Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI Lab 2: GitHub Lab 3: GitHub","title":"Aula 04/03"},{"location":"commum-content/util/Util-Aulas/#aula-2502","text":"Trabalhar com transistores e circuitos integrados. Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI","title":"Aula 25/02"},{"location":"commum-content/util/Util-Aulas/#aula-2302","text":"Estudar l\u00f3gica booleana e praticar Estudo pr\u00e9vio Teoria \u00c1lgebra Booleana Expositiva/ D\u00favidas (45 min) Handout/ Exerc\u00edcio/ Vevox (1h15): \u00c1lgebra Booleana - 1 \u00c1lgebra Booleana - 2","title":"Aula 23/02"},{"location":"commum-content/util/Util-Aulas/#aula-1802","text":"D\u00favidas sobre dados digitais, uma breve vis\u00e3o geral sobre git e github. Estudo pr\u00e9vio Dados digitais Expositiva/ D\u00favidas (0h40): Slides Handout/ Exerc\u00edcio (1h20): Dados Digitais 1 Dados Digitais 2","title":"Aula 18/02"},{"location":"commum-content/util/Util-Aulas/#aula-1602","text":"Aula de apresenta\u00e7\u00e3o da mat\u00e9ria; vis\u00e3o geral do que vai ser feito; cria\u00e7\u00e3o de grupos. Slides (1h00): Slide Prezi Handout/ Estudo/ Exerc\u00edcio (1h00): Montar grupos Mural","title":"Aula 16/02"},{"location":"commum-content/util/Util-Comecando-novo-projeto/","text":"Come\u00e7ando novo projeto \u00b6 Scrum Master O grupo deve escolher um novo mediador Aconselh\u00e1vel no primeiro projeto o facilitador ser aquele que tem mais facilidade git. At\u00e9 que todos tenham sido mediadores, n\u00e3o pode repetir. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor Atualizando infra \u00b6 Warning Todos devem realizar essa etapa: Mediadores e Desenvolvedores Atualizar a infra da disciplina executando o comando a seguir na pasta raiz ro reposit\u00f3rio: Elementos Bits e Proc $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ . pip3 install \"bits-e-proc\" Ir\u00e1 instalar a lib python que possui a infra de testes da disciplina. Antes de come\u00e7ar - Mediador \u00b6 Mediador Somente mediador , mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Antes de come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com os novos arquivos no reposit\u00f3rio oficial da disciplina, e tamb\u00e9m configurar o Travis para executar os testes nesse novo projeto. upstream \u00b6 Abrindo terminal no Linux ctrl + alt + t No terminal: Referenciando reposit\u00f3rio original da disciplina Elementos Bits e Proc $ git remote add upstream https://github.com/insper/Z01.1 $ git remote add upstream git@github.com:Insper/bits-e-proc.git Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout main $ git merge upstream/main Novos arquivos devem ter aparecido no reposit\u00f3rio, para saber quais: $ git diff HEAD~ --name-only Actions \u00b6 Arquivos ocultos No linux os arquivos que come\u00e7am com . s\u00e3o ocultos, ou seja, eles n\u00e3o aparecem normalmente no gerenciador de arquivos ou no comando ls , para ver os arquivos ocultos: No gerenciador de arquivos aperte crtl + h ( h de hide ) ls -a ( onde -a indica all ) Edite o arquivo actions.yml localizado na pasta .github/workflows/ modificando o final do arquivo para ficar como: Elementos Bits e Proc python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py python3 Projetos/C-UnidadeLogicaAritmetica/testeULA.py python3 Projetos/D-LogicaSequencial/testeLogicaSequencial.py TODO Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .github/workflows/actions.yml $ git commit -m \"configurando actions para novo projeto\" SCRUM_MASTER.json \u00b6 O mediador do projeto deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso do projeto B: Projetos/B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. Ap\u00f3s editar esse arquivo deve realizar um commit e fazer o envio para o github: $ git commit -am \"configurado scrum do projeto\" $ git push origin main Note Isso \u00e9 importante pois os professores ir\u00e3o usar esse arquivo para saber quem s\u00e3o os mediadores de cada projeto. Atualizar tools \u00b6 Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh Antes de come\u00e7ar - Desenvolvedores \u00b6 Desenvolvedores Todos desenvolvedores devem fazer essa etapa. Fazer isso somente depois que o mediador fez a parte dele! Volte para a branch main: $ git checkout main Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio local: $ git pull origin main","title":"Come\u00e7ando novo projeto"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#comecando-novo-projeto","text":"Scrum Master O grupo deve escolher um novo mediador Aconselh\u00e1vel no primeiro projeto o facilitador ser aquele que tem mais facilidade git. At\u00e9 que todos tenham sido mediadores, n\u00e3o pode repetir. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor","title":"Come\u00e7ando novo projeto"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#atualizando-infra","text":"Warning Todos devem realizar essa etapa: Mediadores e Desenvolvedores Atualizar a infra da disciplina executando o comando a seguir na pasta raiz ro reposit\u00f3rio: Elementos Bits e Proc $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ . pip3 install \"bits-e-proc\" Ir\u00e1 instalar a lib python que possui a infra de testes da disciplina.","title":"Atualizando infra"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#antes-de-comecar-mediador","text":"Mediador Somente mediador , mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Antes de come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com os novos arquivos no reposit\u00f3rio oficial da disciplina, e tamb\u00e9m configurar o Travis para executar os testes nesse novo projeto.","title":"Antes de come\u00e7ar - Mediador"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#upstream","text":"Abrindo terminal no Linux ctrl + alt + t No terminal: Referenciando reposit\u00f3rio original da disciplina Elementos Bits e Proc $ git remote add upstream https://github.com/insper/Z01.1 $ git remote add upstream git@github.com:Insper/bits-e-proc.git Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout main $ git merge upstream/main Novos arquivos devem ter aparecido no reposit\u00f3rio, para saber quais: $ git diff HEAD~ --name-only","title":"upstream"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#actions","text":"Arquivos ocultos No linux os arquivos que come\u00e7am com . s\u00e3o ocultos, ou seja, eles n\u00e3o aparecem normalmente no gerenciador de arquivos ou no comando ls , para ver os arquivos ocultos: No gerenciador de arquivos aperte crtl + h ( h de hide ) ls -a ( onde -a indica all ) Edite o arquivo actions.yml localizado na pasta .github/workflows/ modificando o final do arquivo para ficar como: Elementos Bits e Proc python3 Projetos/B-LogicaCombinacional/testeLogicaCombinacional.py python3 Projetos/C-UnidadeLogicaAritmetica/testeULA.py python3 Projetos/D-LogicaSequencial/testeLogicaSequencial.py TODO Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .github/workflows/actions.yml $ git commit -m \"configurando actions para novo projeto\"","title":"Actions"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#scrum_masterjson","text":"O mediador do projeto deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso do projeto B: Projetos/B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. Ap\u00f3s editar esse arquivo deve realizar um commit e fazer o envio para o github: $ git commit -am \"configurado scrum do projeto\" $ git push origin main Note Isso \u00e9 importante pois os professores ir\u00e3o usar esse arquivo para saber quem s\u00e3o os mediadores de cada projeto.","title":"SCRUM_MASTER.json"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#atualizar-tools","text":"Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh","title":"Atualizar tools"},{"location":"commum-content/util/Util-Comecando-novo-projeto/#antes-de-comecar-desenvolvedores","text":"Desenvolvedores Todos desenvolvedores devem fazer essa etapa. Fazer isso somente depois que o mediador fez a parte dele! Volte para a branch main: $ git checkout main Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio local: $ git pull origin main","title":"Antes de come\u00e7ar - Desenvolvedores"},{"location":"commum-content/util/Util-VM-Linux/","text":"Boot SSD via VirtualBox \u00b6 Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"commum-content/util/Util-VM-Linux/#boot-ssd-via-virtualbox","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"commum-content/util/Util-VM-MAC/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM MAC"},{"location":"commum-content/util/Util-VM-Windows/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM Windows"},{"location":"commum-content/util/Util-Video-Aulas/","text":"Material desenvolvido pelo Prof. Luciano Soares no ano de 2017, pode ser utilizado para estudar! Conte\u00fado de \u00c1lgebra Booleana https://www.youtube.com/watch?v=YYIucfsQKl4 Conte\u00fado Transistores https://www.youtube.com/watch?v=rRg9wdzlPvE Conte\u00fado sobre Circuitos Integrados https://www.youtube.com/watch?v=zX36rn_lIl0 Conte\u00fado sobre L\u00f3gica Combinacional https://www.youtube.com/watch?v=ImFt9YjEHHc Conte\u00fado Dados Digitais https://www.youtube.com/watch?v=dVixMB1uSYA Conte\u00fado de Unidade L\u00f3gica Aritm\u00e9tica https://www.youtube.com/watch?v=zRX3sOtjS10 Conte\u00fado de L\u00f3gica Sequencial https://www.youtube.com/watch?v=lNW2d26S-gI Conte\u00fado de Mem\u00f3rias https://www.youtube.com/watch?v=CAw-cQUZO_g Conte\u00fado de L\u00f3gica de Controle https://www.youtube.com/watch?v=eEXI72tztws Conte\u00fado Linguagem de M\u00e1quina https://www.youtube.com/watch?v=_MhpD0Geqlk Conte\u00fado Assembly https://www.youtube.com/watch?v=xABQNUe3hG0 Conte\u00fado Computador https://www.youtube.com/watch?v=uVgqGkz106Q Conte\u00fado Assembler https://www.youtube.com/watch?v=xFBPHkaFIlk Conte\u00fado M\u00e1quina Virtual https://www.youtube.com/watch?v=U9DRGBVp8Eg Conte\u00fado Pilhas https://www.youtube.com/watch?v=5N0rTGZHdwY Conte\u00fado de Controle https://www.youtube.com/watch?v=Hp4ZwLMvYfg Conte\u00fado Linguagem de Alto N\u00edvel https://www.youtube.com/watch?v=YZucTUVv-n8 Conte\u00fado Linguagem Orientada a Objetos https://www.youtube.com/watch?v=-9Fj-ShFV_8 Conte\u00fado An\u00e1lise L\u00e9xica e Sint\u00e1tica https://www.youtube.com/watch?v=rtHxrs6TC6Y Programa\u00e7\u00e3o de FPGA pelo Quartus https://www.youtube.com/watch?v=QuH2pduAs34 Exemplo MuxVHDLQuartus https://www.youtube.com/watch?v=m3B8Yob3xkE Gravando e atualizando dados numa mem\u00f3ria de uma FPGA pelo Quartus https://www.youtube.com/watch?v=zb4taQX4yL8","title":"Util Video Aulas"},{"location":"commum-content/util/Util-vixi-sou-scrum/","text":"Vixi! Sou scrum master \u00b6 Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Sincronizar reposit\u00f3rio com upstream Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar GH-Actions para executar teste do projeto Criar Project e issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! e no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio de relat\u00f3rio (p\u00e1gina de projeto) Criar project no github \u00b6 Criando um project no github Adicionando issues Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Vixi! Sou scrum master"},{"location":"commum-content/util/Util-vixi-sou-scrum/#vixi-sou-scrum-master","text":"Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Sincronizar reposit\u00f3rio com upstream Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar GH-Actions para executar teste do projeto Criar Project e issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! e no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio de relat\u00f3rio (p\u00e1gina de projeto)","title":"Vixi! Sou scrum master"},{"location":"commum-content/util/Util-vixi-sou-scrum/#criar-project-no-github","text":"Criando um project no github Adicionando issues Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Criar project no github"},{"location":"commum-content/z01/z01-Cheat-Sheet/","text":"","title":"Z01.1 Cheat Sheet"},{"location":"commum-content/z01/z01-InstructionSet/","text":"Download em PDF","title":"Instruction Set"},{"location":"commum-content/z01/z01-Resumo-Assembly/","text":"Z01 - Resumo Assembly \u00b6 Nota\u00e7\u00e3o reg : Registrador ( %A , %D ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Arquivos: extens\u00f5es .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU Warning Nosso hardware n\u00e3o suporta opera\u00e7\u00f5es que realizam escrita e leitura na mem\u00f3ria RAM ao mesmo tempo. Opera\u00e7\u00f5es como: incw (%A) decw (%A) addw (%A), %D, (%A) subw %D, (%A), (%A) ... V\u00e3o ser aceitas pelo assembler, mas v\u00e3o executar erradas no HW. Instru\u00e7\u00f5es \u00b6 LEA - Carregamento Efetivo do Endere\u00e7o (Valor) \u00b6 leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o leaw armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A MOV - Copia Valores \u00b6 movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: D = RAM[A] movw ( % A ), % D ADD - Adi\u00e7\u00e3o de Inteiros \u00b6 addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: D = RAM[A]+D addw ( % A ), % D , % D SUB - Subtra\u00e7\u00e3o de Inteiros \u00b6 subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa \u00b6 rsubw reg/mem/im*, rem/mem, reg {, reg, reg} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A INC - Incrementa Inteiro \u00b6 incw reg Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D DEC - Decrementa Inteiro \u00b6 decw reg A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A NOT - Nega\u00e7\u00e3o por Complemento de Um \u00b6 notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D NEG - Nega\u00e7\u00e3o por Complemento de dois \u00b6 negw reg A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A AND - Operador E (and) \u00b6 andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D OR - Operador OU (or) \u00b6 orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D JMP - Jump \u00b6 jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp JE - Desvia Execu\u00e7\u00e3o se Igual a Zero \u00b6 je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % D JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero \u00b6 jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D JG - Desvia Execu\u00e7\u00e3o se Maior que Zero \u00b6 jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % D JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero \u00b6 jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % D JL - Desvia Execu\u00e7\u00e3o se Menor que Zero \u00b6 jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % D JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero \u00b6 jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D NOP - N\u00e3o faz nada (No Operation) \u00b6 nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop Descri\u00e7\u00e3o Detalhada \u00b6 Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Resumo Assembly"},{"location":"commum-content/z01/z01-Resumo-Assembly/#z01-resumo-assembly","text":"Nota\u00e7\u00e3o reg : Registrador ( %A , %D ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Arquivos: extens\u00f5es .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU Warning Nosso hardware n\u00e3o suporta opera\u00e7\u00f5es que realizam escrita e leitura na mem\u00f3ria RAM ao mesmo tempo. Opera\u00e7\u00f5es como: incw (%A) decw (%A) addw (%A), %D, (%A) subw %D, (%A), (%A) ... V\u00e3o ser aceitas pelo assembler, mas v\u00e3o executar erradas no HW.","title":"Z01 - Resumo Assembly"},{"location":"commum-content/z01/z01-Resumo-Assembly/#instrucoes","text":"","title":"Instru\u00e7\u00f5es"},{"location":"commum-content/z01/z01-Resumo-Assembly/#lea-carregamento-efetivo-do-endereco-valor","text":"leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o leaw armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A","title":"LEA - Carregamento Efetivo do Endere\u00e7o (Valor)"},{"location":"commum-content/z01/z01-Resumo-Assembly/#mov-copia-valores","text":"movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: D = RAM[A] movw ( % A ), % D","title":"MOV - Copia Valores"},{"location":"commum-content/z01/z01-Resumo-Assembly/#add-adicao-de-inteiros","text":"addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: D = RAM[A]+D addw ( % A ), % D , % D","title":"ADD - Adi\u00e7\u00e3o de Inteiros"},{"location":"commum-content/z01/z01-Resumo-Assembly/#sub-subtracao-de-inteiros","text":"subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A","title":"SUB - Subtra\u00e7\u00e3o de Inteiros"},{"location":"commum-content/z01/z01-Resumo-Assembly/#rsub-subtracao-de-inteiros-reversa","text":"rsubw reg/mem/im*, rem/mem, reg {, reg, reg} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A","title":"RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa"},{"location":"commum-content/z01/z01-Resumo-Assembly/#inc-incrementa-inteiro","text":"incw reg Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D","title":"INC - Incrementa Inteiro"},{"location":"commum-content/z01/z01-Resumo-Assembly/#dec-decrementa-inteiro","text":"decw reg A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A","title":"DEC - Decrementa Inteiro"},{"location":"commum-content/z01/z01-Resumo-Assembly/#not-negacao-por-complemento-de-um","text":"notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D","title":"NOT - Nega\u00e7\u00e3o por Complemento de Um"},{"location":"commum-content/z01/z01-Resumo-Assembly/#neg-negacao-por-complemento-de-dois","text":"negw reg A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A","title":"NEG - Nega\u00e7\u00e3o por Complemento de dois"},{"location":"commum-content/z01/z01-Resumo-Assembly/#and-operador-e-and","text":"andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D","title":"AND - Operador E (and)"},{"location":"commum-content/z01/z01-Resumo-Assembly/#or-operador-ou-or","text":"orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D","title":"OR - Operador OU (or)"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jmp-jump","text":"jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp","title":"JMP - Jump"},{"location":"commum-content/z01/z01-Resumo-Assembly/#je-desvia-execucao-se-igual-a-zero","text":"je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % D","title":"JE - Desvia Execu\u00e7\u00e3o se Igual a Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jne-desvia-execucao-se-diferente-de-zero","text":"jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D","title":"JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jg-desvia-execucao-se-maior-que-zero","text":"jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % D","title":"JG - Desvia Execu\u00e7\u00e3o se Maior que Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jge-desvia-execucao-se-maior-igual-a-zero","text":"jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % D","title":"JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jl-desvia-execucao-se-menor-que-zero","text":"jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % D","title":"JL - Desvia Execu\u00e7\u00e3o se Menor que Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#jle-desvia-execucao-se-menor-igual-a-zero","text":"jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D","title":"JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero"},{"location":"commum-content/z01/z01-Resumo-Assembly/#nop-nao-faz-nada-no-operation","text":"nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop","title":"NOP - N\u00e3o faz nada (No Operation)"},{"location":"commum-content/z01/z01-Resumo-Assembly/#descricao-detalhada","text":"Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Descri\u00e7\u00e3o Detalhada"},{"location":"commum-content/z01/z01-Resumo-VM/","text":"Linguagem VM \u00b6 Nota\u00e7\u00e3o \u00b6 Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False Opera\u00e7\u00f5es \u00b6 add - Adi\u00e7\u00e3o \u00b6 add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> | sub - Subtra\u00e7\u00e3o \u00b6 sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor. neg - Nega\u00e7\u00e3o \u00b6 neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP -> not - not bit a bit \u00b6 and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local. or - Or bit a bit \u00b6 or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. and - and bit a bit \u00b6 and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. eq - Equal \u00b6 eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> | gt - Greater Than \u00b6 gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. lt - Less Than \u00b6 lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. Label \u00b6 Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto. Goto \u00b6 Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome Fun\u00e7\u00e3o \u00b6 A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es: Declara\u00e7\u00e3o de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add Chamada de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2 Par\u00e2metros \u00b6 Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Resumo VM"},{"location":"commum-content/z01/z01-Resumo-VM/#linguagem-vm","text":"","title":"Linguagem VM"},{"location":"commum-content/z01/z01-Resumo-VM/#notacao","text":"Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False","title":"Nota\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#operacoes","text":"","title":"Opera\u00e7\u00f5es"},{"location":"commum-content/z01/z01-Resumo-VM/#add-adicao","text":"add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> |","title":"add - Adi\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#sub-subtracao","text":"sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor.","title":"sub - Subtra\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#neg-negacao","text":"neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP ->","title":"neg - Nega\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#not-not-bit-a-bit","text":"and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local.","title":"not - not bit a bit"},{"location":"commum-content/z01/z01-Resumo-VM/#or-or-bit-a-bit","text":"or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"or - Or bit a bit"},{"location":"commum-content/z01/z01-Resumo-VM/#and-and-bit-a-bit","text":"and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"and - and bit a bit"},{"location":"commum-content/z01/z01-Resumo-VM/#eq-equal","text":"eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> |","title":"eq - Equal"},{"location":"commum-content/z01/z01-Resumo-VM/#gt-greater-than","text":"gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"gt - Greater Than"},{"location":"commum-content/z01/z01-Resumo-VM/#lt-less-than","text":"lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"lt - Less Than"},{"location":"commum-content/z01/z01-Resumo-VM/#label","text":"Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto.","title":"Label"},{"location":"commum-content/z01/z01-Resumo-VM/#goto","text":"Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome","title":"Goto"},{"location":"commum-content/z01/z01-Resumo-VM/#funcao","text":"A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es:","title":"Fun\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#declaracao-de-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add","title":"Declara\u00e7\u00e3o de fun\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#chamada-de-funcao","text":"Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"commum-content/z01/z01-Resumo-VM/#parametros","text":"Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Par\u00e2metros"},{"location":"commum-content/z01/z01-Z01.1-Cheat-Sheet/","text":"","title":"z01 Z01.1 Cheat Sheet"},{"location":"teoria/myhdl-1/","text":"MyHDL B\u00e1sico \u00b6 O MyHDL foi a linguagem escolhida para o desenvolvimento do hardware da disciplina Bits e Processadores, o MyHDL \u00e9 um pacote python que permite descrevermos um hardware (note que n\u00e3o \u00e9 programar um hardware ) utilizando a linguagem Python. O importante \u00e9 saber que descrever um hardware \u00e9 diferente de escrevermos um programa: Um programa em Python/Java/C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do MyHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com ele voc\u00ea ser\u00e1 um arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou. As linguagens de descri\u00e7\u00e3o de hardware s\u00e3o chamadas de Hardware Description Language (HDL) e s\u00e3o muito penosas de aprender (VHDL, VERILOG) pois s\u00e3o complexas e antigas (uma delas foi criada na guerra fria e n\u00e3o foi criada com o prop\u00f3sito que \u00e9 utilizada atualmente), mas existe uma fam\u00edlia de novos HDL que tem ganhado bastante evid\u00eancia na comunidade, e uma delas \u00e9 o MyHDL. O MyHDL serve apenas como uma camada de mais alto n\u00edvel, ele n\u00e3o \u00e9 capaz de criar um hardware funcional na FPGA (hardware que usamos para criarmos nossas cozinhas ). Mas ele consegue gerar um arquivo VHLD que pode ser sintetizado na FPGA e virar um hardware real. IDEA | MIRABORANTE ---> MyHDL --> VHDL --|> FPGA | Conceitos b\u00e1sicos - Hardware \u00b6 Circuitos digitais podem ser descritos como combina\u00e7\u00f5es de circuitos combinacional e sequenciais, circuitos combinacionais s\u00e3o aqueles que a sa\u00edda \"reage\" instantaneamente a mudan\u00e7a do valor da entrada (equa\u00e7\u00f5es booleanas, mux, demux, decoders, ...) e os circuitos sequ\u00eancias s\u00e3o aqueles que depende de um clock, ou que a sa\u00edda n\u00e3o \u00e9 uma a\u00e7\u00e3o imediata da mudan\u00e7a da entrada. Primeiro iremos trabalhar apenas com os circuitos sequ\u00eancias e depois avan\u00e7aremos para os s\u00edncronos (para criar a mem\u00f3ria do nosso processador). Um conceito muito importante que voc\u00eas devem tomar cuidado \u00e9 que quando criamos um hardware, somos capazes de realizar a\u00e7\u00f5es simultaneamente, diferente de um programa que executa \"linha a linha\", um hardware tende a executar tudo ao mesmo tempo (paralelismo). Hardwares s\u00e3o constru\u00eddos atrav\u00e9s de pequenos m\u00f3dulos que formam um sistema mais complexo (hier\u00e1rquico), os m\u00f3dulos podem ser visualizados como componentes eletr\u00f4nicos que interligados em uma placa de circuito impresso (PCB) formam por exemplo um computador. O mesmo m\u00f3dulo pode ser usado mais de uma vez e em diferentes lugares do hardware. Conceitos b\u00e1sicos - MyHDL \u00b6 Warning Lembre que estamos usando o python para descrever um hardware e n\u00e3o um programa! No MyHDL definimos uma inst\u00e2ncia (componente de hardware) usando o decorator : @block na classe, isso define que a classe deve ser interpretada como um componente de hardware. Cada componente de hardware pode possuir internamente v\u00e1rios comportamentos (no caso aqui veremos apenas o combinacional) que s\u00e3o definidos pelos m\u00e9todos da classe com o decorator ( always_comb ). Vamos ver um exemplo que implementa a seguinte equa\u00e7\u00e3o l\u00f3gica: q = a or (b and c) : from myhdl import * @block def equacao ( q , a , b , c ): @always_comb def comb (): q . next = a or ( b and c ) return comb Parece bem ok n\u00e9? Mas tem alguns segredos que vamos analisando aos poucos. No exemplo aparece os decorators: @block (para definir um hardware) e @always_comb (combinacional), o hardware possui apenas uma classe que \u00e9 chamada de comb onde a rela\u00e7\u00e3o entre as entradas e sa\u00edda do hardware \u00e9 definida. Como ilustrado no diagrama a seguir: |------------| a---> ******** | b---> * comb * ----> q c---> ******** | | | | equacao | |------------| A implementa\u00e7\u00e3o da equa\u00e7\u00e3o \u00e9 trivial e utiliza da sintax do python a or (b and c) , mas a sa\u00edda q \u00e9 acessada via o atributo next : q.next . Isso \u00e9 feito porque o argumento q (e os demais) n\u00e3o s\u00e3o vari\u00e1veis comuns do python e sim um tipo especial definido pelo MyHDL, chamada de Signal . Da documenta\u0107\u00e3o do MyHDL: next Read-write attribute that represents the next value of the signal. Info Mais para frente iremos entender melhor o Signal e como utilizamos essa vari\u00e1vel. Testando \u00b6 Para testarmos o bloco de hardware crido anteriormente devemos de alguma forma instanciar o hardware e adicionar est\u00edmulos a entrada dele, este processo em projetos de hardware \u00e9 chamado de testbench . Notem que isso \u00e9 diferente de apenas fazermos a chamada de uma fun\u00e7\u00e3o (que alias vamos entender mais para frente no curso como \u00e9 que funciona). Para os est\u00edmulos iremos devemos criar um m\u00e9todo, que possui um novo decorator chamado instance , que indica que iremos realizar a instancia\u00e7\u00e3o de um componente de hardware (usar o componente), nesse m\u00e9todo iremos criar os est\u00edmulos necess\u00e1rios para testarmos o nosso hardware. Temos que lembrar que quando estamos mexendo com hardware, esses est\u00edmulos acontecem no tempo, por isso temos o yield delay(1) , que indica para a simula\u00e7\u00e3o aguardar por 1 tick de tempo antes de realizar o pr\u00f3ximo processamento. @instance def stimulus (): a . next = 0 b . next = 1 c . next = 1 yield delay ( 1 ) print ( \"q = %s \" % q ) Gera o diagrama: : yield delay(1) : a ---0----:---- :_____ b --------/ 1 :_____ c --------/ 1 :_____ q --------/ (q v\u00e1lido) Tip Importante verificar o uso do next , as vari\u00e1veis s\u00e3o atualizadas todas no mesmo instante! Notem no diagrama que a , b e c e q mudam juntas! Diferente do que aconteceria em um programa python na qual a ordem da atribui\u00e7\u00e3o impacta em quem \u00e9 alterado primeiro. Info O yield delay(1) faz com que as sa\u00eddas .next sejam atualizadas. yield python Voc\u00ea sabe o que \u00e9 o yield ? Ele surgiu no python 2.2 e \u00e9 utilizado pelo MyHDL, ele \u00e9 similar ao return de uma fun\u00e7\u00e3o, mas quando a fun\u00e7\u00e3o \u00e9 chamada novamente ela retorna do ponto que parou. Veja o exemplo a baixo: def foo(): for i in range(3) yield(i) bar = foo() bar.next() >>> 1 bar.next() >>> 2 bar.next() >>> 3 bar.next() >>> Traceback (most recent call last): >>> File \"<stdin>\", line 1, in ? A fun\u00e7\u00e3o foo ficou interativa! Agora temos que juntar o hardware que desejamos testar com o est\u00edmulo criado: q = Signal ( bool ( 0 )) a = Signal ( bool ( 0 )) b = Signal ( bool ( 0 )) c = Signal ( bool ( 0 )) equacao_1 = equacao ( q , a , b , c ) sim = Simulation ( equacao_1 , stimulus ) sim . run () Notem que criamos quatro vari\u00e1veis do tipo Signal(bool(0)) , isso indica para o MyHDL que as vari\u00e1veis q,a,b,c s\u00e3o sinais (entradas e sa\u00eddas do hardware) do tipo bool (bin\u00e1rias), ou seja, s\u00f3 podem assumir 1 ou 0 . Todas as vari\u00e1veis s\u00e3o do tipo bool e inicializadas em 0 . Info Poder\u00edamos inicializar as vari\u00e1veis no estado '1': q = Signal(bool(1)) Ao executar o projeto, obt\u00e9m a seguinte sa\u00edda: >>> q = 1 <class 'myhdl.StopSimulation'>: No more events O resultado obtido \u00e9 o esperado: 1 = 0 or (1 and 1) ! Que bom n\u00e9? Info Realizamos apenas o teste de uma condic\u00e3o no m\u00f3dulo, um teste mais correto deveria ser mais amplo. Depois vamos entender como fazer isso. O que ainda falta aprender do MyHDL \u00b6 Ainda falta entender outros tipos de dados que n\u00e3o bin\u00e1rio ( intbv ), como descrever hardwares sequenciais (dependem de um clock), como converter e executar o projeto em um hardware real!","title":"MyHDL B\u00e1sico"},{"location":"teoria/myhdl-1/#myhdl-basico","text":"O MyHDL foi a linguagem escolhida para o desenvolvimento do hardware da disciplina Bits e Processadores, o MyHDL \u00e9 um pacote python que permite descrevermos um hardware (note que n\u00e3o \u00e9 programar um hardware ) utilizando a linguagem Python. O importante \u00e9 saber que descrever um hardware \u00e9 diferente de escrevermos um programa: Um programa em Python/Java/C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do MyHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com ele voc\u00ea ser\u00e1 um arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou. As linguagens de descri\u00e7\u00e3o de hardware s\u00e3o chamadas de Hardware Description Language (HDL) e s\u00e3o muito penosas de aprender (VHDL, VERILOG) pois s\u00e3o complexas e antigas (uma delas foi criada na guerra fria e n\u00e3o foi criada com o prop\u00f3sito que \u00e9 utilizada atualmente), mas existe uma fam\u00edlia de novos HDL que tem ganhado bastante evid\u00eancia na comunidade, e uma delas \u00e9 o MyHDL. O MyHDL serve apenas como uma camada de mais alto n\u00edvel, ele n\u00e3o \u00e9 capaz de criar um hardware funcional na FPGA (hardware que usamos para criarmos nossas cozinhas ). Mas ele consegue gerar um arquivo VHLD que pode ser sintetizado na FPGA e virar um hardware real. IDEA | MIRABORANTE ---> MyHDL --> VHDL --|> FPGA |","title":"MyHDL B\u00e1sico"},{"location":"teoria/myhdl-1/#conceitos-basicos-hardware","text":"Circuitos digitais podem ser descritos como combina\u00e7\u00f5es de circuitos combinacional e sequenciais, circuitos combinacionais s\u00e3o aqueles que a sa\u00edda \"reage\" instantaneamente a mudan\u00e7a do valor da entrada (equa\u00e7\u00f5es booleanas, mux, demux, decoders, ...) e os circuitos sequ\u00eancias s\u00e3o aqueles que depende de um clock, ou que a sa\u00edda n\u00e3o \u00e9 uma a\u00e7\u00e3o imediata da mudan\u00e7a da entrada. Primeiro iremos trabalhar apenas com os circuitos sequ\u00eancias e depois avan\u00e7aremos para os s\u00edncronos (para criar a mem\u00f3ria do nosso processador). Um conceito muito importante que voc\u00eas devem tomar cuidado \u00e9 que quando criamos um hardware, somos capazes de realizar a\u00e7\u00f5es simultaneamente, diferente de um programa que executa \"linha a linha\", um hardware tende a executar tudo ao mesmo tempo (paralelismo). Hardwares s\u00e3o constru\u00eddos atrav\u00e9s de pequenos m\u00f3dulos que formam um sistema mais complexo (hier\u00e1rquico), os m\u00f3dulos podem ser visualizados como componentes eletr\u00f4nicos que interligados em uma placa de circuito impresso (PCB) formam por exemplo um computador. O mesmo m\u00f3dulo pode ser usado mais de uma vez e em diferentes lugares do hardware.","title":"Conceitos b\u00e1sicos - Hardware"},{"location":"teoria/myhdl-1/#conceitos-basicos-myhdl","text":"Warning Lembre que estamos usando o python para descrever um hardware e n\u00e3o um programa! No MyHDL definimos uma inst\u00e2ncia (componente de hardware) usando o decorator : @block na classe, isso define que a classe deve ser interpretada como um componente de hardware. Cada componente de hardware pode possuir internamente v\u00e1rios comportamentos (no caso aqui veremos apenas o combinacional) que s\u00e3o definidos pelos m\u00e9todos da classe com o decorator ( always_comb ). Vamos ver um exemplo que implementa a seguinte equa\u00e7\u00e3o l\u00f3gica: q = a or (b and c) : from myhdl import * @block def equacao ( q , a , b , c ): @always_comb def comb (): q . next = a or ( b and c ) return comb Parece bem ok n\u00e9? Mas tem alguns segredos que vamos analisando aos poucos. No exemplo aparece os decorators: @block (para definir um hardware) e @always_comb (combinacional), o hardware possui apenas uma classe que \u00e9 chamada de comb onde a rela\u00e7\u00e3o entre as entradas e sa\u00edda do hardware \u00e9 definida. Como ilustrado no diagrama a seguir: |------------| a---> ******** | b---> * comb * ----> q c---> ******** | | | | equacao | |------------| A implementa\u00e7\u00e3o da equa\u00e7\u00e3o \u00e9 trivial e utiliza da sintax do python a or (b and c) , mas a sa\u00edda q \u00e9 acessada via o atributo next : q.next . Isso \u00e9 feito porque o argumento q (e os demais) n\u00e3o s\u00e3o vari\u00e1veis comuns do python e sim um tipo especial definido pelo MyHDL, chamada de Signal . Da documenta\u0107\u00e3o do MyHDL: next Read-write attribute that represents the next value of the signal. Info Mais para frente iremos entender melhor o Signal e como utilizamos essa vari\u00e1vel.","title":"Conceitos b\u00e1sicos - MyHDL"},{"location":"teoria/myhdl-1/#testando","text":"Para testarmos o bloco de hardware crido anteriormente devemos de alguma forma instanciar o hardware e adicionar est\u00edmulos a entrada dele, este processo em projetos de hardware \u00e9 chamado de testbench . Notem que isso \u00e9 diferente de apenas fazermos a chamada de uma fun\u00e7\u00e3o (que alias vamos entender mais para frente no curso como \u00e9 que funciona). Para os est\u00edmulos iremos devemos criar um m\u00e9todo, que possui um novo decorator chamado instance , que indica que iremos realizar a instancia\u00e7\u00e3o de um componente de hardware (usar o componente), nesse m\u00e9todo iremos criar os est\u00edmulos necess\u00e1rios para testarmos o nosso hardware. Temos que lembrar que quando estamos mexendo com hardware, esses est\u00edmulos acontecem no tempo, por isso temos o yield delay(1) , que indica para a simula\u00e7\u00e3o aguardar por 1 tick de tempo antes de realizar o pr\u00f3ximo processamento. @instance def stimulus (): a . next = 0 b . next = 1 c . next = 1 yield delay ( 1 ) print ( \"q = %s \" % q ) Gera o diagrama: : yield delay(1) : a ---0----:---- :_____ b --------/ 1 :_____ c --------/ 1 :_____ q --------/ (q v\u00e1lido) Tip Importante verificar o uso do next , as vari\u00e1veis s\u00e3o atualizadas todas no mesmo instante! Notem no diagrama que a , b e c e q mudam juntas! Diferente do que aconteceria em um programa python na qual a ordem da atribui\u00e7\u00e3o impacta em quem \u00e9 alterado primeiro. Info O yield delay(1) faz com que as sa\u00eddas .next sejam atualizadas. yield python Voc\u00ea sabe o que \u00e9 o yield ? Ele surgiu no python 2.2 e \u00e9 utilizado pelo MyHDL, ele \u00e9 similar ao return de uma fun\u00e7\u00e3o, mas quando a fun\u00e7\u00e3o \u00e9 chamada novamente ela retorna do ponto que parou. Veja o exemplo a baixo: def foo(): for i in range(3) yield(i) bar = foo() bar.next() >>> 1 bar.next() >>> 2 bar.next() >>> 3 bar.next() >>> Traceback (most recent call last): >>> File \"<stdin>\", line 1, in ? A fun\u00e7\u00e3o foo ficou interativa! Agora temos que juntar o hardware que desejamos testar com o est\u00edmulo criado: q = Signal ( bool ( 0 )) a = Signal ( bool ( 0 )) b = Signal ( bool ( 0 )) c = Signal ( bool ( 0 )) equacao_1 = equacao ( q , a , b , c ) sim = Simulation ( equacao_1 , stimulus ) sim . run () Notem que criamos quatro vari\u00e1veis do tipo Signal(bool(0)) , isso indica para o MyHDL que as vari\u00e1veis q,a,b,c s\u00e3o sinais (entradas e sa\u00eddas do hardware) do tipo bool (bin\u00e1rias), ou seja, s\u00f3 podem assumir 1 ou 0 . Todas as vari\u00e1veis s\u00e3o do tipo bool e inicializadas em 0 . Info Poder\u00edamos inicializar as vari\u00e1veis no estado '1': q = Signal(bool(1)) Ao executar o projeto, obt\u00e9m a seguinte sa\u00edda: >>> q = 1 <class 'myhdl.StopSimulation'>: No more events O resultado obtido \u00e9 o esperado: 1 = 0 or (1 and 1) ! Que bom n\u00e9? Info Realizamos apenas o teste de uma condic\u00e3o no m\u00f3dulo, um teste mais correto deveria ser mais amplo. Depois vamos entender como fazer isso.","title":"Testando"},{"location":"teoria/myhdl-1/#o-que-ainda-falta-aprender-do-myhdl","text":"Ainda falta entender outros tipos de dados que n\u00e3o bin\u00e1rio ( intbv ), como descrever hardwares sequenciais (dependem de um clock), como converter e executar o projeto em um hardware real!","title":"O que ainda falta aprender do MyHDL"},{"location":"util/util-infra/","text":"Infra \u00b6 //TODO Na disciplina iremos utilizar","title":"Infra"},{"location":"util/util-infra/#infra","text":"//TODO Na disciplina iremos utilizar","title":"Infra"}]}